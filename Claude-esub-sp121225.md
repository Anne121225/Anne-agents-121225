TW-SmartReview 2030 æ™ºæ…§åŒ–å¯©æŸ¥ä»£ç†äººç³»çµ±æŠ€è¡“è¦æ ¼æ›¸
TW-SmartReview 2030 Agentic System Technical Specifications
ç‰ˆæœ¬ï¼š v4.2.0 (Cinematic Release)
æ—¥æœŸï¼š 2025å¹´12æœˆ15æ—¥
æ©Ÿå¯†ç­‰ç´šï¼š å…§éƒ¨æŠ€è¡“æ–‡ä»¶
æäº¤å–®ä½ï¼š æ™ºæ…§é†«ç™‚æ³•è¦ç§‘å­¸å°ˆæ¡ˆç ”ç©¶å°çµ„æŠ€è¡“é–‹ç™¼éƒ¨

ç›®éŒ„

å°ˆæ¡ˆæ¦‚è¿°
ç³»çµ±æ¶æ§‹è¨­è¨ˆ
æ ¸å¿ƒåŠŸèƒ½æ¨¡çµ„è©³è§£
UIUXè¨­è¨ˆç³»çµ±
AIæ¨¡å‹æ•´åˆç­–ç•¥
è³‡æ–™çµæ§‹èˆ‡å‹åˆ¥å®šç¾©
Streamlitå¯¦ä½œæ¶æ§‹
agentsyamlé…ç½®ç³»çµ±
FDAå°ˆç”¨é€²éšåŠŸèƒ½æ¨¡çµ„
ç³»çµ±æ•ˆèƒ½å„ªåŒ–èˆ‡æ“´å±•æ€§
éƒ¨ç½²èˆ‡ç¶­é‹
çµè«–èˆ‡æœªä¾†å±•æœ›


1. å°ˆæ¡ˆæ¦‚è¿°
1.1 ç³»çµ±å®šä½èˆ‡é¡˜æ™¯
TW-SmartReview 2030 æ˜¯ä¸€å€‹å°ˆç‚ºè¡›ç”Ÿç¦åˆ©éƒ¨é£Ÿå“è—¥ç‰©ç®¡ç†ç½²(TFDA)ä»¥åŠç¾åœ‹é£Ÿå“è—¥ç‰©ç®¡ç†å±€(FDA)è¨­è¨ˆçš„æ¬¡ä¸–ä»£æ™ºæ…§å¯©æŸ¥ç³»çµ±ã€‚æœ¬ç³»çµ±æ¡ç”¨ä»£ç†å‹äººå·¥æ™ºæ…§(Agentic AI)æ¶æ§‹,é€éå¤šå€‹å°ˆè·AIä»£ç†äººçš„å”åŒé‹ä½œ,å¯¦ç¾é†«ç™‚å™¨ææŸ¥é©—ç™»è¨˜æ–‡ä»¶çš„è‡ªå‹•åŒ–è§£æã€æ³•è¦ç¬¦åˆæ€§æª¢æŸ¥ã€é¢¨éšªè©•ä¼°ä»¥åŠç§‘å­¸å¯©æŸ¥ç­‰è¤‡é›œä»»å‹™ã€‚
åœ¨ç•¶å‰é†«ç™‚å™¨æç”¢æ¥­å¿«é€Ÿç™¼å±•çš„èƒŒæ™¯ä¸‹,å¯©æŸ¥æ©Ÿé—œé¢è‡¨è‘—æ–‡ä»¶æ•¸é‡çˆ†ç‚¸æ€§å¢é•·ã€æŠ€è¡“è¤‡é›œåº¦æå‡ä»¥åŠå¯©æŸ¥æ¨™æº–åœ‹éš›åŒ–ç­‰å¤šé‡æŒ‘æˆ°ã€‚å‚³çµ±çš„äººå·¥å¯©æŸ¥æ¨¡å¼å·²é›£ä»¥æ»¿è¶³æ•ˆç‡èˆ‡å“è³ªçš„é›™é‡è¦æ±‚ã€‚TW-SmartReview 2030 é€éå¼•å…¥å…ˆé€²çš„å¤§å‹èªè¨€æ¨¡å‹(LLM)æŠ€è¡“èˆ‡å¤šä»£ç†äººå”ä½œæ©Ÿåˆ¶,åœ¨ä¿æŒå¯©æŸ¥åš´è¬¹æ€§çš„åŒæ™‚,å¤§å¹…æå‡è™•ç†æ•ˆç‡,å¯¦ç¾ã€Œæ™ºæ…§å¢å¼·å‹å¯©æŸ¥ã€(AI-Augmented Review)çš„å‰µæ–°æ¨¡å¼ã€‚
1.2 æ ¸å¿ƒè¨­è¨ˆç†å¿µ
æœ¬ç³»çµ±å»ºç«‹åœ¨äº”å¤§æ ¸å¿ƒæ”¯æŸ±ä¹‹ä¸Š:
1.2.1 æ™ºæ…§åŒ–(Intelligence)
é‹ç”¨Google Gemini 2.5 Flashç­‰æœ€å…ˆé€²çš„å¤šæ¨¡æ…‹å¤§å‹èªè¨€æ¨¡å‹,ç³»çµ±èƒ½å¤ :

è‡ªå‹•ç†è§£è¤‡é›œçš„é†«ç™‚å™¨ææŠ€è¡“æ–‡ä»¶,åŒ…æ‹¬æƒæå¼PDFã€æ‰‹å¯«è¨»è¨˜ç­‰éçµæ§‹åŒ–å…§å®¹
è­˜åˆ¥é—œéµè³‡è¨Šç‰‡æ®µ,å¦‚è‡¨åºŠè©¦é©—çµ‚é»ã€é›»æ°£å®‰å…¨åƒæ•¸ã€ç”Ÿç‰©ç›¸å®¹æ€§æ¸¬è©¦çµæœ
é€éçŸ¥è­˜åœ–è­œèˆ‡å‘é‡æª¢ç´¢æŠ€è¡“,å¿«é€Ÿå®šä½ç›¸é—œæ³•è¦æ¢æ–‡èˆ‡æ­·å²æ¡ˆä¾‹
é€²è¡Œå¤šæ­¥é©Ÿæ¨ç†,è©•ä¼°æ–‡ä»¶é‚è¼¯ä¸€è‡´æ€§èˆ‡æ•¸æ“šæ”¯æ’å……åˆ†æ€§

1.2.2 è‡ªå‹•åŒ–(Automation)
é€éå·¥ä½œæµç¨‹ç·¨æ’(Workflow Orchestration)æŠ€è¡“,ç³»çµ±èƒ½å¤ :

è‡ªå‹•åˆ†é…å¯©æŸ¥ä»»å‹™è‡³å°ˆè²¬ä»£ç†äºº,ç„¡éœ€äººå·¥èª¿åº¦
æ‰¹æ¬¡è™•ç†å¤šä»½æ–‡ä»¶,æ”¯æ´å„ªå…ˆç´šæ’ç¨‹èˆ‡ä¾è³´éˆç®¡ç†
è‡ªå‹•ç”Ÿæˆçµæ§‹åŒ–å¯©æŸ¥å ±å‘Š,åŒ…å«æ‘˜è¦ã€ç™¼ç¾äº‹é …ã€å»ºè­°æ”¹å–„æªæ–½
æ•´åˆé›»å­ç°½æ ¸ç³»çµ±,å¯¦ç¾ç«¯åˆ°ç«¯çš„ç„¡ç´™åŒ–ä½œæ¥­æµç¨‹

1.2.3 é€æ˜åŒ–(Transparency)
ç‚ºç¬¦åˆç›£ç®¡ç§‘å­¸(Regulatory Science)çš„åš´è¬¹è¦æ±‚,ç³»çµ±ç¢ºä¿:

æ‰€æœ‰AIæ¨ç†éç¨‹å‡å¯è¿½æº¯,æä¾›æ±ºç­–ä¾æ“šèˆ‡åƒè€ƒè³‡æ–™ä¾†æº
å¯¦ä½œå€å¡Šéˆç¨½æ ¸è»Œè·¡,è¨˜éŒ„æ¯ä¸€æ¬¡æ–‡ä»¶ä¿®æ”¹ã€å¯©æŸ¥æ„è¦‹èˆ‡æ ¸å‡†å‹•ä½œ
æ”¯æ´ã€Œå¯è§£é‡‹AIã€(Explainable AI, XAI)æŠ€è¡“,å°‡é»‘ç®±æ¨¡å‹çš„åˆ¤æ–·é‚è¼¯è¦–è¦ºåŒ–
æä¾›å®Œæ•´çš„æ“ä½œæ—¥èªŒèˆ‡æ™‚é–“æˆ³è¨˜,ç¬¦åˆFDA 21 CFR Part 11é›»å­è¨˜éŒ„è¦æ±‚

1.2.4 å”åŒåŒ–(Collaboration)
æ¨¡æ“¬çœŸå¯¦ä¸–ç•Œè·¨éƒ¨é–€å¯©æŸ¥åœ˜éšŠçš„é‹ä½œæ¨¡å¼:

å®šç¾©å¤šå€‹å°ˆæ¥­é ˜åŸŸä»£ç†äºº(è‡¨åºŠè©•ä¼°ã€é›»æ°£å®‰å…¨ã€è»Ÿé«”é©—è­‰ã€ç”Ÿç‰©ç›¸å®¹æ€§ç­‰)
é€éä¸­å¤®ç·¨æ’å™¨(Orchestrator)å”èª¿ä»£ç†äººé–“çš„è³‡è¨Šå‚³éèˆ‡ä»»å‹™ä¾è³´
æ”¯æ´äººæ©Ÿå”ä½œ(Human-in-the-Loop),é—œéµæ±ºç­–é»ä¿ç•™äººå·¥å¯©æ ¸
æ•´åˆå³æ™‚é€šè¨Šèˆ‡å”ä½œå·¥å…·,ä¿ƒé€²å¯©æŸ¥å“¡ã€å» å•†èˆ‡æŠ€è¡“å°ˆå®¶çš„æºé€š

1.2.5 éš±ç§å„ªå…ˆ(Privacy-First)
æ¡ç”¨å…ˆé€²çš„éš±ç§ä¿è­·æŠ€è¡“:

ç„¡å¾Œç«¯æ¶æ§‹(Backendless Architecture)
æ”¯æ´è¯é‚¦å­¸ç¿’(Federated Learning)
å¯¦ä½œå·®åˆ†éš±ç§(Differential Privacy)
ç¬¦åˆGDPRã€HIPAAç­‰åœ‹éš›éš±ç§æ³•è¦è¦æ±‚

1.3 ç›®æ¨™ä½¿ç”¨è€…ç¾¤é«”
æœ¬ç³»çµ±è¨­è¨ˆæ™‚å……åˆ†è€ƒé‡ä¸åŒä½¿ç”¨è€…è§’è‰²çš„éœ€æ±‚:
ä½¿ç”¨è€…é¡å‹ä¸»è¦éœ€æ±‚ç³»çµ±åŠŸèƒ½æ”¯æ´TFDA/FDAå¯©æŸ¥å“¡æå‡å¯©æŸ¥æ•ˆç‡ã€ç¢ºä¿ä¸€è‡´æ€§ã€æ¸›å°‘äººç‚ºç–æ¼è‡ªå‹•åŒ–åˆå¯©ã€æ™ºæ…§æ¯”å°ã€é¢¨éšªåˆ†ç´šã€å ±å‘Šç”Ÿæˆé†«æè£½é€ å•†æ³•è¦äººå“¡é€å¯©å‰è‡ªæˆ‘æª¢æŸ¥ã€é™ä½è£œä»¶ç‡ã€ç¸®çŸ­å¯©æŸ¥é€±æœŸPre-submission Reviewã€ç¼ºé™·åµæ¸¬ã€æ³•è¦æŒ‡å¼•ç¬¬ä¸‰æ–¹æŸ¥é©—é¡§å•å°ˆæ¥­æœå‹™å·¥å…·ã€æå‡æœå‹™å“è³ªã€æ“´å¤§æœå‹™é‡èƒ½æ‰¹æ¬¡è™•ç†ã€å®¢è£½åŒ–å ±å‘Šã€å¤šå°ˆæ¡ˆç®¡ç†å­¸è¡“ç ”ç©¶æ©Ÿæ§‹æ•™å­¸æ¡ˆä¾‹ã€ç ”ç©¶ç´ æã€æ³•è¦ç§‘å­¸ç™¼å±•åŒ¿ååŒ–æ¡ˆä¾‹åº«ã€çµ±è¨ˆåˆ†æã€è¶¨å‹¢è¦–è¦ºåŒ–
1.4 æŠ€è¡“å‰µæ–°äº®é»
ç›¸è¼ƒæ–¼å‚³çµ±çš„æ–‡ä»¶ç®¡ç†ç³»çµ±æˆ–ç°¡å–®çš„é—œéµå­—æœå°‹å·¥å…·,TW-SmartReview 2030å…·å‚™ä»¥ä¸‹çªç ´æ€§å‰µæ–°:

å¤šæ¨¡æ…‹æ–‡ä»¶ç†è§£,æ›´èƒ½ç†è§£åœ–è¡¨ã€æµç¨‹åœ–ã€é›»è·¯åœ–ç­‰è¦–è¦ºå…ƒç´ 
å‹•æ…‹ä»£ç†äººç·¨æ’
é›»å½±ç´šäº’å‹•ä»‹é¢,æä¾›æ²‰æµ¸å¼ä½¿ç”¨è€…é«”é©—
è—è¡“é¢¨æ ¼å¼•æ“+ç¨®è¦–è¦ºä¸»é¡Œ,å€‹æ€§åŒ–å·¥ä½œç’°å¢ƒ
Streamlitå¿«é€ŸåŸå‹


2. ç³»çµ±æ¶æ§‹è¨­è¨ˆ
2.1 æ•´é«”æ¶æ§‹æ¦‚è¦½
TW-SmartReview 2030æ¡ç”¨å¾®æœå‹™å°å‘æ¶æ§‹(Microservices-Oriented Architecture)çµåˆäº‹ä»¶é©…å‹•è¨­è¨ˆ(Event-Driven Design),å¯¦ç¾é«˜åº¦æ¨¡çµ„åŒ–èˆ‡å¯æ“´å±•æ€§ã€‚ç³»çµ±ç”±ä»¥ä¸‹æ ¸å¿ƒå±¤ç´šçµ„æˆ:
Copyâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    ä½¿ç”¨è€…ä»‹é¢å±¤ (UI Layer)                â”‚
â”‚          Streamlit Web App + Custom Components          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                   æ‡‰ç”¨é‚è¼¯å±¤ (Logic Layer)                â”‚
â”‚    Session State Management + Workflow Orchestration    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                   ä»£ç†äººåŸ·è¡Œå±¤ (Agent Layer)              â”‚
â”‚  Clinical Evaluator | Electrical Safety | Risk Analyzer â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                   AIæ¨è«–å±¤ (Inference Layer)              â”‚
â”‚        Google Gemini API + Vector Database (Pinecone)    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                   è³‡æ–™å­˜å–å±¤ (Data Layer)                 â”‚
â”‚    File Storage + Knowledge Base + Audit Trail (SQLite) â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
2.2 StreamlitæŠ€è¡“å †ç–Š
æœ¬ç³»çµ±é¸æ“‡Streamlitä½œç‚ºå‰ç«¯æ¡†æ¶,ç›¸è¼ƒæ–¼å‚³çµ±çš„React/Vue.jsç­‰JavaScriptæ¡†æ¶,å…·å‚™ä»¥ä¸‹å„ªå‹¢:
2.2.1 æ ¸å¿ƒå„ªå‹¢

ç´”Pythoné–‹ç™¼,é™ä½æŠ€è¡“æ£§è¤‡é›œåº¦
å³æ™‚ç†±é‡è¼‰,æ¥µè‡´é–‹ç™¼é«”é©—
å…§å»ºå…ƒä»¶è±å¯Œã€åœ–è¡¨ã€å¤šåª’é«”å…ƒä»¶é–‹ç®±å³ç”¨
Session Stateç®¡ç†
åŸç”Ÿæ”¯æ´è³‡æ–™ç§‘å­¸å¥—ä»¶ã€NumPyã€Plotlyç­‰

2.2.2 æŠ€è¡“å †ç–Šæ¸…å–®
é¡åˆ¥æŠ€è¡“/å¥—ä»¶ç‰ˆæœ¬ç”¨é€”æ ¸å¿ƒæ¡†æ¶Streamlit1.32.0+Webæ‡‰ç”¨æ¡†æ¶èªè¨€Python3.11+ä¸»è¦é–‹ç™¼èªè¨€AIæ¨è«–google-generativeai0.4.0+Gemini APIå®¢æˆ¶ç«¯æ–‡ä»¶è™•ç†PyMuPDF (fitz)1.23.0+PDFè§£æèˆ‡æ¸²æŸ“å‘é‡æª¢ç´¢pinecone-client3.0.0+å‘é‡è³‡æ–™åº«å®¢æˆ¶ç«¯è³‡æ–™è™•ç†pandas2.2.0+çµæ§‹åŒ–è³‡æ–™æ“ä½œè¦–è¦ºåŒ–plotly5.18.0+äº’å‹•å¼åœ–è¡¨é…ç½®ç®¡ç†PyYAML6.0+YAMLæª”æ¡ˆè§£ææ—¥èªŒè¨˜éŒ„loguru0.7.0+çµæ§‹åŒ–æ—¥èªŒç’°å¢ƒè®Šæ•¸python-dotenv1.0.0+ç’°å¢ƒé…ç½®ç®¡ç†
2.3 è³‡æ–™æµæ¶æ§‹
ç³»çµ±æ¡ç”¨å–®å‘è³‡æ–™æµ(Unidirectional Data Flow)è¨­è¨ˆæ¨¡å¼,ç¢ºä¿ç‹€æ…‹è®ŠåŒ–çš„å¯é æ¸¬æ€§:
pythonCopy# è³‡æ–™æµå‘ç¤ºæ„
ä½¿ç”¨è€…ä¸Šå‚³æ–‡ä»¶ 
    â†“
æ–‡ä»¶å‰è™•ç†å™¨(Preprocessor)
    â†“
LLM-OCRæœå‹™(OCR Service)
    â†“
Contextæå–èˆ‡å­˜å„²(Session State)
    â†“
ä»£ç†äººç·¨æ’å™¨(Orchestrator)
    â†“
å¹³è¡Œ/åºåˆ—åŸ·è¡Œä»£ç†äºº(Agents Execution)
    â†“
çµæœèšåˆå™¨(Result Aggregator)
    â†“
UIå³æ™‚æ›´æ–°(Real-time UI Update)
2.3.1 Session Stateç®¡ç†ç­–ç•¥
Streamlitçš„æ ¸å¿ƒæ©Ÿåˆ¶æ˜¯åœ¨æ¯æ¬¡ä½¿ç”¨è€…äº’å‹•æ™‚é‡æ–°åŸ·è¡Œæ•´å€‹è…³æœ¬ã€‚ç‚ºé¿å…ç‹€æ…‹ä¸Ÿå¤±èˆ‡é‡è¤‡é‹ç®—,ç³»çµ±å¯¦ä½œä»¥ä¸‹ç­–ç•¥:
pythonCopy# core/session_manager.py
import streamlit as st
from typing import Any, Optional

class SessionManager:
    """é›†ä¸­å¼Session Stateç®¡ç†å™¨"""
    
    @staticmethod
    def initialize():
        """åˆå§‹åŒ–æ‰€æœ‰å¿…è¦çš„sessionè®Šæ•¸"""
        defaults = {
            'processed_documents': [],
            'active_agents': [],
            'review_results': {},
            'system_logs': [],
            'current_painter_style': 'cyberpunk',
            'api_key_configured': False,
            'user_notes': '',
            'workflow_status': 'idle'  # idle, processing, completed, error
        }
        
        for key, value in defaults.items():
            if key not in st.session_state:
                st.session_state[key] = value
    
    @staticmethod
    def get(key: str, default: Any = None) -> Any:
        """å®‰å…¨åœ°ç²å–sessionè®Šæ•¸"""
        return st.session_state.get(key, default)
    
    @staticmethod
    def set(key: str, value: Any):
        """è¨­å®šsessionè®Šæ•¸"""
        st.session_state[key] = value
    
    @staticmethod
    def append(key: str, value: Any):
        """å‘åˆ—è¡¨é¡å‹çš„sessionè®Šæ•¸è¿½åŠ å…ƒç´ """
        if key not in st.session_state:
            st.session_state[key] = []
        st.session_state[key].append(value)
2.4 å®‰å…¨æ€§æ¶æ§‹
2.4.1 å¤šå±¤é˜²ç¦¦ç­–ç•¥
ç³»çµ±å¯¦ä½œç¸±æ·±é˜²ç¦¦(Defense in Depth)å®‰å…¨æ¨¡å‹:
Copyâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Layer 1: ç¶²è·¯å±¤é˜²è­·                 â”‚
â”‚  - HTTPSå¼·åˆ¶åŠ å¯†                    â”‚
â”‚  - Rate Limiting (APIé–˜é“)          â”‚
â”‚  - DDoSé˜²è­· (Cloudflare)            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Layer 2: æ‡‰ç”¨å±¤é˜²è­·                 â”‚
â”‚  - API KeyåŠ å¯†å­˜å„²                  â”‚
â”‚  - Session Tokené©—è­‰                â”‚
â”‚  - CSRF Tokenä¿è­·                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Layer 3: è³‡æ–™å±¤é˜²è­·                 â”‚
â”‚  - æ•æ„Ÿè³‡æ–™åŠ å¯† (AES-256)           â”‚
â”‚  - å­˜å–æ§åˆ¶åˆ—è¡¨ (ACL)               â”‚
â”‚  - ç¨½æ ¸æ—¥èªŒ (Immutable Log)         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Layer 4: åˆè¦æ€§æ§åˆ¶                 â”‚
â”‚  - GDPRè³‡æ–™ä¸»é«”æ¬Šåˆ©                 â”‚
â”‚  - HIPAAå­˜å–å¯©è¨ˆ                    â”‚
â”‚  - FDA 21 CFR Part 11é›»å­ç°½ç«        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
2.4.2 API Keyç®¡ç†å¯¦ä½œ
pythonCopy# core/security.py
import os
from cryptography.fernet import Fernet
from typing import Optional

class APIKeyManager:
    """APIé‡‘é‘°å®‰å…¨ç®¡ç†å™¨"""
    
    def __init__(self):
        # å¾ç’°å¢ƒè®Šæ•¸æˆ–ä½¿ç”¨è€…ä¸»å¯†ç¢¼æ´¾ç”ŸåŠ å¯†é‡‘é‘°
        self.cipher_suite = self._initialize_cipher()
    
    def _initialize_cipher(self) -> Fernet:
        """åˆå§‹åŒ–åŠ å¯†å™¨"""
        # å„ªå…ˆä½¿ç”¨ç’°å¢ƒè®Šæ•¸ä¸­çš„åŠ å¯†é‡‘é‘°
        encryption_key = os.getenv('ENCRYPTION_KEY')
        if not encryption_key:
            # è‹¥ç„¡ç’°å¢ƒè®Šæ•¸,ä½¿ç”¨ç¡¬é«”æŒ‡ç´‹+é¹½å€¼ç”Ÿæˆ
            encryption_key = Fernet.generate_key()
        return Fernet(encryption_key)
    
    def store_api_key(self, api_key: str) -> bool:
        """åŠ å¯†ä¸¦å­˜å„²APIé‡‘é‘°"""
        try:
            encrypted_key = self.cipher_suite.encrypt(api_key.encode())
            # åƒ…å­˜æ–¼session state,ä¸å¯«å…¥ç£ç¢Ÿ
            SessionManager.set('encrypted_api_key', encrypted_key)
            SessionManager.set('api_key_configured', True)
            return True
        except Exception as e:
            st.error(f"é‡‘é‘°å­˜å„²å¤±æ•—: {str(e)}")
            return False
    
    def retrieve_api_key(self) -> Optional[str]:
        """è§£å¯†ä¸¦å–å¾—APIé‡‘é‘°"""
        encrypted_key = SessionManager.get('encrypted_api_key')
        if not encrypted_key:
            # å˜—è©¦å¾ç’°å¢ƒè®Šæ•¸è®€å–
            return os.getenv('GEMINI_API_KEY')
        
        try:
            decrypted_key = self.cipher_suite.decrypt(encrypted_key)
            return decrypted_key.decode()
        except Exception:
            return None
    
    def validate_key(self, api_key: str) -> bool:
        """é©—è­‰APIé‡‘é‘°æœ‰æ•ˆæ€§"""
        # é€²è¡Œæ¸¬è©¦æ€§APIå‘¼å«
        try:
            import google.generativeai as genai
            genai.configure(api_key=api_key)
            model = genai.GenerativeModel('gemini-2.5-flash')
            # ç™¼é€æ¥µç°¡æ¸¬è©¦è«‹æ±‚
            response = model.generate_content("Test")
            return True
        except Exception as e:
            st.warning(f"APIé‡‘é‘°é©—è­‰å¤±æ•—: {str(e)}")
            return False

3. æ ¸å¿ƒåŠŸèƒ½æ¨¡çµ„è©³è§£
3.1 æ™ºæ…§å„€è¡¨æ¿æ¨¡çµ„
3.1.1 æ¨¡çµ„æ¶æ§‹
æ™ºæ…§å„€è¡¨æ¿ä½æ–¼æ‡‰ç”¨ç¨‹å¼é¦–é ,æä¾›ç³»çµ±ç‹€æ…‹çš„å…¨æ™¯è¦–åœ–èˆ‡é—œéµæŒ‡æ¨™ç›£æ§ã€‚
pythonCopy# pages/1_ğŸ“Š_Dashboard.py
import streamlit as st
import plotly.express as px
import plotly.graph_objects as go
from datetime import datetime, timedelta
import pandas as pd

def render_dashboard():
    """æ¸²æŸ“æ™ºæ…§å„€è¡¨æ¿"""
    st.set_page_config(
        page_title="TW-SmartReview 2030 å„€è¡¨æ¿",
        page_icon="ğŸ“Š",
        layout="wide"
    )
    
    # å¥—ç”¨ç•¶å‰è—è¡“é¢¨æ ¼
    apply_painter_style(SessionManager.get('current_painter_style'))
    
    # æ¨™é¡Œå€
    col1, col2 = st.columns([3, 1])
    with col1:
        st.title("ğŸ¯ TW-SmartReview 2030 æ™ºæ…§å„€è¡¨æ¿")
        st.caption(f"æœ€å¾Œæ›´æ–°: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    
    with col2:
        # ç³»çµ±ç‹€æ…‹æŒ‡ç¤ºå™¨
        status = SessionManager.get('workflow_status')
        status_color = {
            'idle': 'ğŸŸ¢',
            'processing': 'ğŸ”µ', 
            'completed': 'ğŸŸ¢',
            'error': 'ğŸ”´'
        }
        st.metric(
            label="ç³»çµ±ç‹€æ…‹",
            value=status_color.get(status, 'âšª') + " " + status.upper()
        )
    
    # é—œéµæŒ‡æ¨™å¡ç‰‡å€
    render_kpi_cards()
    
    # åœ–è¡¨å€
    render_charts()
    
    # æ´»èºä»£ç†äººç¶²çµ¡è¦–è¦ºåŒ–
    render_agent_network()

def render_kpi_cards():
    """æ¸²æŸ“é—œéµç¸¾æ•ˆæŒ‡æ¨™å¡ç‰‡"""
    col1, col2, col3, col4 = st.columns(4)
    
    # æ¨¡æ“¬æ•¸æ“š (å¯¦éš›æ‡‰å¾è³‡æ–™åº«æˆ–session stateå–å¾—)
    metrics = {
        'æœ¬æœˆå¯©æŸ¥æ¡ˆä»¶': (124, +12),
        'å¹³å‡å¯©æŸ¥æ™‚é•·': ('3.2å¤©', -0.5),
        'å¯©æŸ¥é€šéç‡': ('87%', +3),
        'AI Tokenä½¿ç”¨': ('2.3M', +150000)
    }
    
    with col1:
        st.metric(
            label="ğŸ“ æœ¬æœˆå¯©æŸ¥æ¡ˆä»¶",
            value=metrics['æœ¬æœˆå¯©æŸ¥æ¡ˆä»¶'][0],
            delta=f"+{metrics['æœ¬æœˆå¯©æŸ¥æ¡ˆä»¶'][1]} è¼ƒä¸Šæœˆ"
        )
    
    with col2:
        st.metric(
            label="â±ï¸ å¹³å‡å¯©æŸ¥æ™‚é•·",
            value=metrics['å¹³å‡å¯©æŸ¥æ™‚é•·'][0],
            delta=f"{metrics['å¹³å‡å¯©æŸ¥æ™‚é•·'][1]}å¤© è¼ƒä¸Šæœˆ",
            delta_color="inverse"  # æ•¸å€¼æ¸›å°‘æ˜¯å¥½äº‹
        )
    
    with col3:
        st.metric(
            label="âœ… å¯©æŸ¥é€šéç‡",
            value=metrics['å¯©æŸ¥é€šéç‡'][0],
            delta=f"+{metrics['å¯©æŸ¥é€šéç‡'][1]}% è¼ƒä¸Šæœˆ"
        )
    
    with col4:
        st.metric(
            label="ğŸ¤– AI Tokenä½¿ç”¨",
            value=metrics['AI Tokenä½¿ç”¨'][0],
            delta=f"+{metrics['AI Tokenä½¿ç”¨'][1]} è¼ƒä¸Šæœˆ"
        )

def render_charts():
    """æ¸²æŸ“çµ±è¨ˆåœ–è¡¨"""
    tab1, tab2, tab3 = st.tabs(["ğŸ“ˆ å¯©æŸ¥è¶¨å‹¢", "ğŸ“Š æ¡ˆä»¶åˆ†å¸ƒ", "ğŸ¯ æ•ˆç‡åˆ†æ"])
    
    with tab1:
        # æ™‚é–“åºåˆ—è¶¨å‹¢åœ–
        df_trend = generate_trend_data()
        fig = px.area(
            df_trend,
            x='æ—¥æœŸ',
            y=['é€ä»¶æ•¸', 'å®Œæˆå¯©æŸ¥æ•¸'],
            title='è¿‘30æ—¥å¯©æŸ¥è¶¨å‹¢',
            labels={'value': 'æ¡ˆä»¶æ•¸', 'variable': 'é¡åˆ¥'}
        )
        st.plotly_chart(fig, use_container_width=True)
    
    with tab2:
        # æ¡ˆä»¶åˆ†é¡åœ“é¤…åœ–
        df_category = pd.DataFrame({
            'å™¨æé¡åˆ¥': ['è¨ºæ–·è©¦åŠ‘', 'æ¤å…¥ç‰©', 'é«”å¤–å¾ªç’°', 'é›»æ°£è¨­å‚™', 'è»Ÿé«”'],
            'æ¡ˆä»¶æ•¸': [45, 32, 18, 23, 6]
        })
        fig = px.pie(
            df_category,
            values='æ¡ˆä»¶æ•¸',
            names='å™¨æé¡åˆ¥',
            title='æœ¬æœˆæ¡ˆä»¶é¡åˆ¥åˆ†å¸ƒ'
        )
        st.plotly_chart(fig, use_container_width=True)
    
    with tab3:
        # å¯©æŸ¥æ•ˆç‡å°æ¯”é•·æ¢åœ–
        df_efficiency = pd.DataFrame({
            'å¯©æŸ¥éšæ®µ': ['æ–‡ä»¶æ¥æ”¶', 'åˆæ­¥å¯©æŸ¥', 'AIè¼”åŠ©åˆ†æ', 'å°ˆå®¶è¤‡æ ¸', 'æœ€çµ‚æ ¸å®š'],
            'äººå·¥å¯©æŸ¥(å°æ™‚)': [2, 48, 0, 24, 8],
            'AIè¼”åŠ©å¯©æŸ¥(å°æ™‚)': [1, 12, 4, 16, 6]
        })
        fig = go.Figure(data=[
            go.Bar(name='äººå·¥å¯©æŸ¥', x=df_efficiency['å¯©æŸ¥éšæ®µ'], y=df_efficiency['äººå·¥å¯©æŸ¥(å°æ™‚)']),
            go.Bar(name='AIè¼”åŠ©å¯©æŸ¥', x=df_efficiency['å¯©æŸ¥éšæ®µ'], y=df_efficiency['AIè¼”åŠ©å¯©æŸ¥(å°æ™‚)'])
        ])
        fig.update_layout(barmode='group', title='å¯©æŸ¥æµç¨‹æ•ˆç‡å°æ¯”')
        st.plotly_chart(fig, use_container_width=True)
3.1.2 å‹•æ…‹ä»£ç†äººç¶²çµ¡è¦–è¦ºåŒ–
ä½¿ç”¨Plotlyå»ºç«‹å³æ™‚æ›´æ–°çš„ä»£ç†äººé€£æ¥åœ–:
pythonCopydef render_agent_network():
    """æ¸²æŸ“ä»£ç†äººç¥ç¶“ç¶²çµ¡è¦–è¦ºåŒ–"""
    st.subheader("ğŸ•¸ï¸ ä»£ç†äººå”ä½œç¶²çµ¡")
    
    active_agents = SessionManager.get('active_agents', [])
    
    if not active_agents:
        st.info("å°šç„¡æ´»èºä»£ç†äººã€‚è«‹å…ˆä¸Šå‚³æ–‡ä»¶ä¸¦å•Ÿå‹•å¯©æŸ¥æµç¨‹ã€‚")
        return
    
    # æ§‹å»ºç¶²çµ¡åœ–è³‡æ–™
    import networkx as nx
    
    G = nx.Graph()
    
    # æ·»åŠ ä¸­å¿ƒç¯€é»
    G.add_node("Orchestrator", node_type="hub")
    
    # æ·»åŠ ä»£ç†äººç¯€é»
    for agent in active_agents:
        G.add_node(
            agent['id'],
            node_type="agent",
            status=agent['status'],
            name=agent['name']
        )
        # é€£æ¥è‡³ä¸­å¿ƒç¯€é»
        G.add_edge("Orchestrator", agent['id'])
    
    # æ·»åŠ ä»£ç†äººé–“çš„ä¾è³´é—œä¿‚
    for agent in active_agents:
        for dep in agent.get('dependencies', []):
            if dep in [a['id'] for a in active_agents]:
                G.add_edge(agent['id'], dep, edge_type="dependency")
    
    # è¨ˆç®—ä½ˆå±€
    pos = nx.spring_layout(G, k=0.5, iterations=50)
    
    # æº–å‚™Plotlyè³‡æ–™
    edge_trace = []
    for edge in G.edges():
        x0, y0 = pos[edge[0]]
        x1, y1 = pos[edge[1]]
        edge_trace.append(
            go.Scatter(
                x=[x0, x1, None],
                y=[y0, y1, None],
                mode='lines',
                line=dict(width=2, color='#888'),
                hoverinfo='none'
            )
        )
    
    node_trace = go.Scatter(
        x=[],
        y=[],
        text=[],
        mode='markers+text',
        hoverinfo='text',
        marker=dict(
            size=[],
            color=[],
            line=dict(width=2, color='white')
        ),
        textposition="top center"
    )
    
    status_colors = {
        'idle': '#gray',
        'running': '#3b82f6',
        'completed': '#10b981',
        'failed': '#ef4444'
    }
    
    for node in G.nodes():
        x, y = pos[node]
        node_trace['x'] += tuple([x])
        node_trace['y'] += tuple([y])
        
        if node == "Orchestrator":
            node_trace['marker']['size'] += tuple([40])
            node_trace['marker']['color'] += tuple(['#8b5cf6'])
            node_trace['text'] += tuple(['ğŸ¯ Orchestrator'])
        else:
            agent_data = next((a for a in active_agents if a['id'] == node), None)
            if agent_data:
                node_trace['marker']['size'] += tuple([30])
                node_trace['marker']['color'] += tuple([status_colors.get(agent_data['status'], '#gray')])
                node_trace['text'] += tuple([agent_data['name']])
    
    # çµ„åˆåœ–è¡¨
    fig = go.Figure(
        data=edge_trace + [node_trace],
        layout=go.Layout(
            showlegend=False,
            hovermode='closest',
            margin=dict(b=0, l=0, r=0, t=0),
            xaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
            yaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
            plot_bgcolor='rgba(0,0,0,0)',
            height=500
        )
    )
    
    st.plotly_chart(fig, use_container_width=True)
    
    # ä»£ç†äººç‹€æ…‹è¡¨æ ¼
    st.dataframe(
        pd.DataFrame([
            {
                'ä»£ç†äºº': a['name'],
                'ç‹€æ…‹': a['status'],
                'é–‹å§‹æ™‚é–“': a.get('start_time', 'N/A'),
                'Tokenä½¿ç”¨': a.get('token_usage', 0)
            }
            for a in active_agents
        ]),
        use_container_width=True
    )
3.2 æ–‡ä»¶è™•ç†æ¨¡çµ„
3.2.1 å¤šæ ¼å¼æ–‡ä»¶æ”å–å™¨
pythonCopy# components/file_processor.py
import streamlit as st
import PyMuPDF as fitz  # PyMuPDF
from PIL import Image
import io
from typing import List, Dict, Optional

class FileProcessor:
    """å¤šæ ¼å¼æ–‡ä»¶è™•ç†å™¨"""
    
    SUPPORTED_FORMATS = {
        'application/pdf': 'PDF',
        'text/plain': 'TXT',
        'text/markdown': 'Markdown',
        'application/json': 'JSON',
        'image/png': 'PNG',
        'image/jpeg': 'JPEG',
        'image/tiff': 'TIFF'
    }
    
    MAX_FILE_SIZE = 50 * 1024 * 1024  # 50MB
    
    @staticmethod
    def render_uploader():
        """æ¸²æŸ“æ–‡ä»¶ä¸Šå‚³ä»‹é¢"""
        st.subheader("ğŸ“¤ æ–‡ä»¶ä¸Šå‚³")
        
        uploaded_files = st.file_uploader(
            "æ”¯æ´æ ¼å¼: PDF, TXT, Markdown, JSON, PNG, JPG, TIFF",
            type=['pdf', 'txt', 'md', 'json', 'png', 'jpg', 'jpeg', 'tiff'],
            accept_multiple_files=True,
            help="å–®æª”æœ€å¤§50MB,ç¸½è¨ˆæœ€å¤§200MB"
        )
        
        if uploaded_files:
            return FileProcessor._process_files(uploaded_files)
        return None
    
    @staticmethod
    def _process_files(files: List) -> List[Dict]:
        """è™•ç†ä¸Šå‚³çš„æ–‡ä»¶"""
        processed_docs = []
        
        progress_bar = st.progress(0)
        status_text = st.empty()
        
        for idx, file in enumerate(files):
            status_text.text(f"è™•ç†ä¸­: {file.name} ({idx+1}/{len(files)})")
            
            # æª¢æŸ¥æª”æ¡ˆå¤§å°
            if file.size > FileProcessor.MAX_FILE_SIZE:
                st.warning(f"âš ï¸ {file.name} è¶…éå¤§å°é™åˆ¶(50MB),å·²è·³é")
                continue
            
            # æ ¹æ“šMIMEé¡å‹è™•ç†
            if file.type == 'application/pdf':
                doc_data = FileProcessor._process_pdf(file)
            elif file.type.startswith('image/'):
                doc_data = FileProcessor._process_image(file)
            elif file.type in ['text/plain', 'text/markdown']:
                doc_data = FileProcessor._process_text(file)
            elif file.type == 'application/json':
                doc_data = FileProcessor._process_json(file)
            else:
                st.error(f"âŒ ä¸æ”¯æ´çš„æª”æ¡ˆæ ¼å¼: {file.type}")
                continue
            
            if doc_data:
                processed_docs.append(doc_data)
            
            progress_bar.progress((idx + 1) / len(files))
        
        status_text.text(f"âœ… å®Œæˆè™•ç† {len(processed_docs)} ä»½æ–‡ä»¶")
        return processed_docs
    
    @staticmethod
    def _process_pdf(file) -> Optional[Dict]:
        """è™•ç†PDFæª”æ¡ˆ"""
        try:
            pdf_bytes = file.read()
            pdf_document = fitz.open(stream=pdf_bytes, filetype="pdf")
            
            # é ç¢¼ç¯„åœé¸æ“‡
            total_pages = pdf_document.page_count
            st.info(f"ğŸ“„ æª”æ¡ˆ {file.name} å…± {total_pages} é ")
            
            page_range = st.text_input(
                f"é¸æ“‡é ç¢¼ç¯„åœ (ä¾‹: 1-5, 10, 15-20)",
                value=f"1-{total_pages}",
                key=f"page_range_{file.name}"
            )
            
            selected_pages = FileProcessor._parse_page_range(page_range, total_pages)
            
            # æå–æ–‡å­—èˆ‡åœ–ç‰‡
            extracted_text = ""
            images = []
            
            for page_num in selected_pages:
                page = pdf_document[page_num - 1]  # 0-indexed
                extracted_text += page.get_text()
                
                # æå–åœ–ç‰‡
                image_list = page.get_images()
                for img_index, img in enumerate(image_list):
                    xref = img[0]
                    base_image = pdf_document.extract_image(xref)
                    images.append({
                        'page': page_num,
                        'index': img_index,
                        'data': base_image["image"]
                    })
            
            pdf_document.close()
            
            return {
                'filename': file.name,
                'type': 'pdf',
                'total_pages': total_pages,
                'selected_pages': selected_pages,
                'text': extracted_text,
                'images': images,
                'size': file.size,
                'upload_time': datetime.now()
            }
            
        except Exception as e:
            st.error(f"PDFè™•ç†å¤±æ•—: {str(e)}")
            return None
    
    @staticmethod
    def _parse_page_range(range_str: str, total_pages: int) -> List[int]:
        """è§£æé ç¢¼ç¯„åœå­—ä¸²"""
        pages = set()
        parts = range_str.split(',')
        
        for part in parts:
            part = part.strip()
            if '-' in part:
                start, end = part.split('-')
                start = int(start.strip())
                end = int(end.strip())
                pages.update(range(start, min(end, total_pages) + 1))
            else:
                page = int(part)
                if 1 <= page <= total_pages:
                    pages.add(page)
        
        return sorted(list(pages))
3.2.2 LLM-OCRæœå‹™
pythonCopy# services/ocr_service.py
import google.generativeai as genai
from typing import Dict, Optional
import base64

class LLMOCRService:
    """åŸºæ–¼LLMçš„å…‰å­¸å­—å…ƒè¾¨è­˜æœå‹™"""
    
    def __init__(self, api_key: str):
        genai.configure(api_key=api_key)
        self.model = genai.GenerativeModel('gemini-2.5-flash')
    
    async def extract_text_from_pdf(
        self,
        pdf_bytes: bytes,
        page_range: Optional[str] = None,
        language: str = 'zh-TW'
    ) -> Dict:
        """å¾PDFæå–æ–‡å­—"""
        
        # å°‡PDFè½‰æ›ç‚ºbase64
        pdf_base64 = base64.b64encode(pdf_bytes).decode('utf-8')
        
        prompt = self._build_ocr_prompt(page_range, language)
        
        try:
            response = await self.model.generate_content_async([
                {
                    'mime_type': 'application/pdf',
                    'data': pdf_base64
                },
                prompt
            ])
            
            return {
                'success': True,
                'text': response.text,
                'token_count': response.usage_metadata.total_token_count,
                'method': 'llm-ocr'
            }
            
        except Exception as e:
            return {
                'success': False,
                'error': str(e),
                'method': 'llm-ocr'
            }
    
    def _build_ocr_prompt(self, page_range: Optional[str], language: str) -> str:
        """æ§‹å»ºOCRæç¤ºè©"""
        return f"""
ä½ æ˜¯ä¸€å€‹å°ˆæ¥­çš„é†«ç™‚å™¨ææ–‡ä»¶å…‰å­¸å­—å…ƒè¾¨è­˜ç³»çµ±ã€‚

ã€ä»»å‹™ã€‘
å¾æä¾›çš„PDFæ–‡ä»¶ä¸­æå–æ‰€æœ‰æ–‡å­—å…§å®¹ã€‚

ã€è¦æ±‚ã€‘
1. ä¿æŒåŸå§‹æ’ç‰ˆçµæ§‹(æ¨™é¡Œã€æ®µè½ã€æ¸…å–®ã€è¡¨æ ¼)
2. ç²¾ç¢ºè¾¨è­˜å°ˆæ¥­è¡“èª(é†«ç™‚å™¨æåç¨±ã€æ³•è¦ç·¨è™Ÿã€æ¸¬è©¦æ¨™æº–)
3. å°æ–¼è¡¨æ ¼,ä½¿ç”¨Markdownè¡¨æ ¼æ ¼å¼è¼¸å‡º
4. å°æ–¼æ¨¡ç³Šæˆ–ç„¡æ³•è¾¨è­˜çš„æ–‡å­—,æ¨™è¨»ç‚º[UNCLEAR]
5. ä¿ç•™æ–‡ä»¶ä¸­çš„å¤šèªè¨€å…§å®¹(ä¸­è‹±æ–‡æ··åˆ)

{f'ã€è™•ç†ç¯„åœã€‘åƒ…è™•ç†ç¬¬ {page_range} é ' if page_range else 'ã€è™•ç†ç¯„åœã€‘è™•ç†æ‰€æœ‰é é¢'}

ã€è¼¸å‡ºèªè¨€ã€‘{language}

ã€è¼¸å‡ºæ ¼å¼ã€‘ç´”Markdownæ–‡å­—,ä¸è¦åŒ…å«ä»»ä½•é¡å¤–èªªæ˜

é–‹å§‹æå–:
"""
3.3 ä»£ç†äººç·¨æ’æ¨¡çµ„
3.3.1 agents.yamlé…ç½®æª”æ¡ˆ
ç³»çµ±çš„ä»£ç†äººå®šç¾©å®Œå…¨é€éYAMLé…ç½®æª”æ¡ˆé€²è¡Œç®¡ç†:
yamlCopy# config/agents.yaml
meta:
  version: "4.2.0"
  last_updated: "2025-12-15"
  description: "TW-SmartReview 2030 ä»£ç†äººé…ç½®æª”æ¡ˆ"

agents:
  - id: clinical-evaluator
    name: è‡¨åºŠè©•ä¼°å°ˆå®¶
    name_en: Clinical Evaluation Specialist
    role: è©•ä¼°è‡¨åºŠè©¦é©—æ•¸æ“šçš„å®Œæ•´æ€§èˆ‡ç§‘å­¸æ€§
    category: clinical
    icon: "ğŸ¥"
    priority: 1
    enabled: true
    dependencies: []
    
    system_prompt: |
      ä½ æ˜¯ä¸€ä½æ“æœ‰15å¹´ç¶“é©—çš„è‡¨åºŠè©•ä¼°å°ˆå®¶,å°ˆç²¾æ–¼é†«ç™‚å™¨æè‡¨åºŠè©¦é©—è©•ä¼°ã€‚
      
      ã€ä½ çš„ä»»å‹™ã€‘
      å¯©æŸ¥è‡¨åºŠè©¦é©—æ–‡ä»¶,è©•ä¼°å…¶ç§‘å­¸æ€§ã€å®Œæ•´æ€§èˆ‡æ³•è¦ç¬¦åˆæ€§ã€‚
      
      ã€è©•ä¼°é‡é»ã€‘
      1. æ¨£æœ¬æ•¸è¨ˆç®—çš„åˆç†æ€§(çµ±è¨ˆæª¢å®šåŠ›åˆ†æ)
      2. ä¸»è¦çµ‚é»(Primary Endpoint)èˆ‡æ¬¡è¦çµ‚é»çš„é¸æ“‡é©ç•¶æ€§
      3. çµ±è¨ˆæ–¹æ³•çš„æ­£ç¢ºæ€§(ITTåˆ†æã€Per-protocolåˆ†æ)
      4. ä¸è‰¯äº‹ä»¶å ±å‘Šçš„å®Œæ•´æ€§èˆ‡å› æœé—œä¿‚åˆ¤å®š
      5. çŸ¥æƒ…åŒæ„æµç¨‹çš„åˆè¦æ€§
      6. è©¦é©—è¨­è¨ˆçš„åå·®æ§åˆ¶(ç›²æ³•ã€éš¨æ©ŸåŒ–)
      
      ã€è¼¸å‡ºæ ¼å¼ã€‘
      # è‡¨åºŠè©•ä¼°å ±å‘Š
      
      ## åŸ·è¡Œæ‘˜è¦
      [ç°¡è¦æ¦‚è¿°ä¸»è¦ç™¼ç¾]
      
      ## è©¦é©—è¨­è¨ˆè©•ä¼°
      - **è©¦é©—é¡å‹**: [RCT/å–®è‡‚/è§€å¯Ÿæ€§]
      - **æ¨£æœ¬æ•¸**: [å¯¦éš›/è¨ˆç•«] 
      - **ä¸»è¦çµ‚é»**: [æè¿°]
      - **è©•ä¼°**: [PASS/FAIL/éœ€è£œå……è³‡æ–™]
      
      ## æ•¸æ“šå®Œæ•´æ€§æª¢æŸ¥
      [è©³ç´°åˆ†æ]
      
      ## ä¸è‰¯äº‹ä»¶åˆ†æ
      [äº‹ä»¶æ¸…å–®èˆ‡åš´é‡ç¨‹åº¦è©•ä¼°]
      
      ## æ³•è¦ç¬¦åˆæ€§
      - ISO 14155ç¬¦åˆåº¦: [%]
      - GCPç¬¦åˆåº¦: [%]
      
      ## å»ºè­°äº‹é …
      1. [å»ºè­°1]
      2. [å»ºè­°2]
      
      ## é¢¨éšªç­‰ç´š
      [LOW/MEDIUM/HIGH/CRITICAL]
      
    generation_config:
      max_output_tokens: 4096
      temperature: 0.3
      top_p: 0.9
      top_k: 40
    
    safety_settings:
      - category: HARM_CATEGORY_MEDICAL_ADVICE
        threshold: BLOCK_MEDIUM_AND_ABOVE
  
  - id: electrical-safety
    name: é›»æ°£å®‰å…¨å¯©æŸ¥å“¡
    name_en: Electrical Safety Reviewer
    role: æª¢æŸ¥é›»æ°£å®‰å…¨æ¨™æº–ç¬¦åˆæ€§
    category: engineering
    icon: "âš¡"
    priority: 2
    enabled: true
    dependencies: []
    
    system_prompt: |
      ä½ æ˜¯ä¸€ä½é›»æ°£å®‰å…¨å·¥ç¨‹å¸«,å°ˆç²¾æ–¼IEC 60601-1æ¨™æº–ã€‚
      
      ã€ä½ çš„ä»»å‹™ã€‘
      å¯©æŸ¥é†«ç™‚é›»æ°£è¨­å‚™çš„å®‰å…¨æ€§è¨­è¨ˆæ–‡ä»¶ã€‚
      
      ã€æª¢æŸ¥é …ç›®ã€‘
      1. é›»æ°£çµ•ç·£ç­‰ç´š(å·¥ä½œé›»å£“ã€çµ•ç·£è€å£“æ¸¬è©¦)
      2. æ¼é›»æµé™å€¼(æ¥åœ°æ¼é›»æµã€å¤–æ®¼æ¼é›»æµã€æ‚£è€…æ¼é›»æµ)
      3. ä¿è­·æ¥åœ°ç³»çµ±å®Œæ•´æ€§
      4. EMCé›»ç£ç›¸å®¹æ€§(IEC 60601-1-2)
      5. é›»æ± å®‰å…¨æ€§(éå……/éæ”¾ä¿è­·)
      6. æ¨™ç¤ºèˆ‡è­¦èªå®Œæ•´æ€§
      
      ã€åƒè€ƒæ¨™æº–ã€‘
      - IEC 60601-1:2005+AMD1:2012+AMD2:2020
      - IEC 60601-1-2:2014 (EMC)
      - IEC 60601-1-6:2010 (Usability)
      
      ã€è¼¸å‡ºæ ¼å¼ã€‘
      # é›»æ°£å®‰å…¨å¯©æŸ¥å ±å‘Š
      
      ## å™¨æåˆ†é¡
      - **é˜²é›»æ“Šç­‰ç´š**: [Class I/II/III]
      - **æ‡‰ç”¨éƒ¨åˆ†**: [B/BF/CFå‹]
      
      ## ç¬¦åˆæ€§æª¢æŸ¥è¡¨
      | é …ç›® | è¦æ±‚å€¼ | å¯¦æ¸¬å€¼ | åˆ¤å®š |
      |------|--------|--------|------|
      | æ¥åœ°æ¼é›»æµ | <500ÂµA | [æ•¸å€¼] | [âœ“/âœ—] |
      
      ## é¢¨éšªè©•ä¼°
      [è­˜åˆ¥çš„é¢¨éšªé»]
      
      ## å»ºè­°æªæ–½
      [æ”¹å–„å»ºè­°]
  
  - id: software-verification
    name: è»Ÿé«”é©—è­‰å°ˆå®¶
    name_en: Software Verification Specialist
    role: è©•ä¼°è»Ÿé«”ç”Ÿå‘½é€±æœŸæ–‡ä»¶èˆ‡é©—è­‰æ¸¬è©¦
    category: software
    icon: "ğŸ’»"
    priority: 3
    enabled: true
    dependencies: []
    
    system_prompt: |
      ä½ æ˜¯ä¸€ä½é†«ç™‚è»Ÿé«”é©—è­‰å°ˆå®¶,å°ˆç²¾æ–¼IEC 62304æ¨™æº–ã€‚
      
      ã€ä½ çš„ä»»å‹™ã€‘
      å¯©æŸ¥é†«ç™‚å™¨æè»Ÿé«”(SaMD/SiMD)çš„é–‹ç™¼èˆ‡é©—è­‰æ–‡ä»¶ã€‚
      
      ã€è©•ä¼°é‡é»ã€‘
      1. è»Ÿé«”å®‰å…¨åˆ†é¡(Class A/B/C)çš„åˆç†æ€§
      2. è»Ÿé«”éœ€æ±‚è¦æ ¼(SRS)çš„å®Œæ•´æ€§èˆ‡å¯è¿½æº¯æ€§
      3. è»Ÿé«”è¨­è¨ˆæ–‡ä»¶(SDD)çš„æ¶æ§‹åˆç†æ€§
      4. å–®å…ƒæ¸¬è©¦ã€æ•´åˆæ¸¬è©¦ã€ç³»çµ±æ¸¬è©¦çš„è¦†è“‹ç‡
      5. é¢¨éšªç®¡ç†æª”æ¡ˆ(ä¾ISO 14971)
      6. ç¶²è·¯å®‰å…¨è€ƒé‡(FDA Cybersecurity Guidance)
      
      ã€è¼¸å‡ºæ ¼å¼ã€‘
      # è»Ÿé«”é©—è­‰å ±å‘Š
      
      ## è»Ÿé«”æè¿°
      - **SOUPå…ƒä»¶**: [ç¬¬ä¸‰æ–¹è»Ÿé«”æ¸…å–®]
      - **å®‰å…¨ç­‰ç´š**: [A/B/C]
      
      ## éœ€æ±‚è¿½æº¯çŸ©é™£æª¢æŸ¥
      [éœ€æ±‚â†’è¨­è¨ˆâ†’æ¸¬è©¦çš„å¯è¿½æº¯æ€§]
      
      ## æ¸¬è©¦è¦†è“‹ç‡åˆ†æ
      - ç¨‹å¼ç¢¼è¦†è“‹ç‡: [%]
      - éœ€æ±‚è¦†è“‹ç‡: [%]
      
      ## ç¶²è·¯å®‰å…¨è©•ä¼°
      [æ¼æ´æƒæçµæœã€åŠ å¯†æ©Ÿåˆ¶æª¢æŸ¥]
      
      ## ç¬¦åˆæ€§çµè«–
      [æ˜¯å¦ç¬¦åˆIEC 62304è¦æ±‚]
  
  - id: biocompatibility
    name: ç”Ÿç‰©ç›¸å®¹æ€§è©•ä¼°å¸«
    name_en: Biocompatibility Assessor
    role: è©•ä¼°ç”Ÿç‰©å®‰å…¨æ€§æ¸¬è©¦æ•¸æ“š
    category: biological
    icon: "ğŸ§¬"
    priority: 4
    enabled: true
    dependencies: []
    
    system_prompt: |
      ä½ æ˜¯ä¸€ä½ç”Ÿç‰©ç›¸å®¹æ€§è©•ä¼°å°ˆå®¶,å°ˆç²¾æ–¼ISO 10993ç³»åˆ—æ¨™æº–ã€‚
      
      ã€ä½ çš„ä»»å‹™ã€‘
      æ ¹æ“šå™¨æçš„æ¥è§¸æ€§è³ªèˆ‡æŒçºŒæ™‚é–“,è©•ä¼°æ‰€éœ€çš„ç”Ÿç‰©ç›¸å®¹æ€§æ¸¬è©¦é …ç›®èˆ‡çµæœã€‚
      
      ã€è©•ä¼°æµç¨‹ã€‘
      1. åˆ¤å®šå™¨æçš„æ¥è§¸é¡åˆ¥(è¡¨é¢æ¥è§¸/å¤–éƒ¨é€£é€š/æ¤å…¥)
      2. åˆ¤å®šæ¥è§¸æ™‚é–“(æš«æ™‚/çŸ­æœŸ/é•·æœŸ)
      3. ä¾ISO 10993-1æ±ºå®šå¿…è¦æ¸¬è©¦é …ç›®
      4. å¯©æŸ¥æ¸¬è©¦å ±å‘Šçš„å®Œæ•´æ€§èˆ‡åˆæ ¼æ€§
      
      ã€æ¸¬è©¦é …ç›®å°ç…§ã€‘
      - ç´°èƒæ¯’æ€§(ISO 10993-5)
      - è‡´æ•æ€§(ISO 10993-10)
      - åˆºæ¿€æ€§(ISO 10993-10)
      - å…¨èº«æ¯’æ€§(ISO 10993-11)
      - æ¤å…¥åæ‡‰(ISO 10993-6)
      - éºå‚³æ¯’æ€§(ISO 10993-3)
      - è¡€æ¶²ç›¸å®¹æ€§(ISO 10993-4)
      - è‡´ç™Œæ€§(ISO 10993-3)
      
      ã€è¼¸å‡ºæ ¼å¼ã€‘
      # ç”Ÿç‰©ç›¸å®¹æ€§è©•ä¼°å ±å‘Š
      
      ## å™¨æè³‡è¨Š
      - **æ¥è§¸é¡åˆ¥**: [é¡åˆ¥]
      - **æ¥è§¸æ™‚é–“**: [æ™‚é–“]
      
      ## æ‰€éœ€æ¸¬è©¦é …ç›®æ¸…å–®
      | æ¸¬è©¦é …ç›® | ISOæ¨™æº– | è¦æ±‚ | ç‹€æ…‹ |
      |----------|---------|------|------|
      
      ## æ¸¬è©¦çµæœè©•ä¼°
      [å„é …æ¸¬è©¦çš„é€šé/å¤±æ•—åˆ¤å®š]
      
      ## ææ–™å®‰å…¨æ€§çµè«–
      [æ•´é«”ç”Ÿç‰©ç›¸å®¹æ€§è©•ä¼°çµè«–]
  
  - id: risk-manager
    name: é¢¨éšªç®¡ç†å°ˆå®¶
    name_en: Risk Management Specialist
    role: åŸ·è¡ŒISO 14971é¢¨éšªåˆ†æ
    category: quality
    icon: "âš ï¸"
    priority: 5
    enabled: true
    dependencies:
      - clinical-evaluator
      - electrical-safety
      - software-verification
      - biocompatibility
    
    system_prompt: |
      ä½ æ˜¯ä¸€ä½é¢¨éšªç®¡ç†å°ˆå®¶,å°ˆç²¾æ–¼ISO 14971:2019æ¨™æº–ã€‚
      
      ã€ä½ çš„ä»»å‹™ã€‘
      æ•´åˆæ‰€æœ‰å°ˆæ¥­é ˜åŸŸä»£ç†äººçš„ç™¼ç¾,é€²è¡Œç¶œåˆé¢¨éšªè©•ä¼°ã€‚
      
      ã€é¢¨éšªåˆ†ææ–¹æ³•ã€‘
      1. æ”¶é›†æ‰€æœ‰å·²è­˜åˆ¥çš„å±å®³(Hazards)
      2. åˆ†æå±å®³æƒ…å¢ƒ(Hazardous Situations)
      3. ä¼°è¨ˆé¢¨éšª(Severity Ã— Probability)
      4. è©•ä¼°é¢¨éšªå¯æ¥å—æ€§
      5. å»ºè­°é¢¨éšªæ§åˆ¶æªæ–½
      6. è©•ä¼°æ®˜é¤˜é¢¨éšª
      
      ã€é¢¨éšªçŸ©é™£ã€‘
      åš´é‡åº¦: 1(å¯å¿½ç•¥) ~ 5(ç½é›£æ€§)
      ç™¼ç”Ÿæ©Ÿç‡: A(æ¥µç½•è¦‹) ~ E(é »ç¹)
      
      ã€è¼¸å‡ºæ ¼å¼ã€‘
      # ç¶œåˆé¢¨éšªç®¡ç†å ±å‘Š
      
      ## é¢¨éšªå½™ç¸½è¡¨
      | é¢¨éšªID | å±å®³æè¿° | åš´é‡åº¦ | æ©Ÿç‡ | é¢¨éšªç­‰ç´š | æ§åˆ¶æªæ–½ |
      |--------|----------|--------|------|----------|----------|
      
      ## é«˜é¢¨éšªé …ç›®è©³ç´°åˆ†æ
      [é‡å°é«˜é¢¨éšªé …ç›®çš„æ·±å…¥æ¢è¨]
      
      ## é¢¨éšª/æ•ˆç›Šåˆ†æ
      [æ®˜é¤˜é¢¨éšªæ˜¯å¦å¯æ¥å—]
      
      ## ä¸Šå¸‚å¾Œç›£æ§è¨ˆç•«å»ºè­°
      [å»ºè­°çš„PMSç›£æ¸¬é …ç›®]
  
  - id: regulatory-mapper
    name: æ³•è¦æ™ºæ…§æ¯”å°å¼•æ“
    name_en: Regulatory Intelligence Mapper
    role: æ¯”å°å¤šåœ‹æ³•è¦è¦æ±‚
    category: regulatory
    icon: "ğŸ“‹"
    priority: 6
    enabled: true
    dependencies: []
    
    system_prompt: |
      ä½ æ˜¯ä¸€ä½åœ‹éš›æ³•è¦å°ˆå®¶,ç†Ÿæ‚‰TFDAã€FDAã€CEã€PMDAç­‰å¤šåœ‹æ³•è¦è¦æ±‚ã€‚
      
      ã€ä½ çš„ä»»å‹™ã€‘
      æ¯”å°é€å¯©æ–‡ä»¶èˆ‡ç›®æ¨™å¸‚å ´çš„æ³•è¦è¦æ±‚,è­˜åˆ¥ç¼ºå£ã€‚
      
      ã€æ³•è¦è³‡æ–™åº«ã€‘
      - TFDA: é†«ç™‚å™¨æç®¡ç†è¾¦æ³•ã€æŸ¥é©—ç™»è¨˜å¯©æŸ¥æº–å‰‡
      - FDA: 510(k), PMA, De Novo pathways
      - EU MDR: Regulation (EU) 2017/745
      - Japan PMDA: PMD Act
      
      ã€è¼¸å‡ºæ ¼å¼ã€‘
      # æ³•è¦ç¬¦åˆæ€§æ¯”å°å ±å‘Š
      
      ## ç›®æ¨™å¸‚å ´åˆ†æ
      - **ä¸»è¦å¸‚å ´**: [TFDA/FDA/CE]
      - **å™¨æåˆ†é¡**: [å„å¸‚å ´çš„åˆ†é¡]
      
      ## æ³•è¦è¦æ±‚å°ç…§è¡¨
      | è¦æ±‚é …ç›® | TFDA | FDA | EU MDR | ç¬¦åˆç‹€æ…‹ |
      |----------|------|-----|--------|----------|
      
      ## ç¼ºå£åˆ†æ
      [ç¼ºå°‘çš„æ–‡ä»¶æˆ–æ¸¬è©¦]
      
      ## é€å¯©ç­–ç•¥å»ºè­°
      [å„ªå…ˆç”³è«‹å¸‚å ´ã€åŒæ­¥é€å¯©å¯è¡Œæ€§]

# ä»£ç†äººç¾¤çµ„å®šç¾©
agent_groups:
  - id: essential-review
    name: åŸºæœ¬å¯©æŸ¥çµ„
    description: æ‰€æœ‰æ¡ˆä»¶çš„å¿…è¦å¯©æŸ¥é …ç›®
    agents:
      - clinical-evaluator
      - electrical-safety
      - biocompatibility
      - risk-manager
  
  - id: software-intensive
    name: è»Ÿé«”å¯†é›†å¯©æŸ¥çµ„
    description: è»Ÿé«”ç‚ºä¸»è¦åŠŸèƒ½çš„å™¨æ
    agents:
      - clinical-evaluator
      - software-verification
      - risk-manager
      - regulatory-mapper
  
  - id: full-review
    name: å®Œæ•´å¯©æŸ¥çµ„
    description: é«˜é¢¨éšªå™¨æçš„å…¨é¢å¯©æŸ¥
    agents:
      - clinical-evaluator
      - electrical-safety
      - software-verification
      - biocompatibility
      - risk-manager
      - regulatory-mapper
3.3.2 ç·¨æ’å™¨æ ¸å¿ƒå¯¦ä½œ
pythonCopy# core/orchestrator.py
import streamlit as st
import yaml
import asyncio
from typing import List, Dict, Optional
from loguru import logger
import google.generativeai as genai

class AgentOrchestrator:
    """ä»£ç†äººç·¨æ’å™¨"""
    
    def __init__(self, config_path: str = "config/agents.yaml"):
        self.config = self._load_config(config_path)
        self.agents = self._initialize_agents()
        self.execution_queue = []
    
    def _load_config(self, path: str) -> Dict:
        """è¼‰å…¥agents.yamlé…ç½®"""
        try:
            with open(path, 'r', encoding='utf-8') as f:
                return yaml.safe_load(f)
        except Exception as e:
            logger.error(f"é…ç½®æª”æ¡ˆè¼‰å…¥å¤±æ•—: {e}")
            st.error(f"âŒ ç„¡æ³•è¼‰å…¥ä»£ç†äººé…ç½®: {str(e)}")
            return {}
    
    def _initialize_agents(self) -> List[Dict]:
        """åˆå§‹åŒ–ä»£ç†äººåˆ—è¡¨"""
        agents = []
        for agent_def in self.config.get('agents', []):
            if agent_def.get('enabled', True):
                agents.append({
                    **agent_def,
                    'status': 'idle',
                    'output': '',
                    'error': None,
                    'start_time': None,
                    'end_time': None,
                    'token_usage': 0
                })
        return agents
    
    def render_agent_selector(self) -> List[str]:
        """æ¸²æŸ“ä»£ç†äººé¸æ“‡ä»‹é¢"""
        st.subheader("ğŸ¤– é¸æ“‡å¯©æŸ¥ä»£ç†äºº")
        
        # å¿«é€Ÿç¾¤çµ„é¸æ“‡
        groups = self.config.get('agent_groups', [])
        if groups:
            st.write("**å¿«é€Ÿç¾¤çµ„:**")
            group_cols = st.columns(len(groups))
            selected_group = None
            
            for idx, group in enumerate(groups):
                with group_cols[idx]:
                    if st.button(
                        f"{group['name']}\n({len(group['agents'])}å€‹ä»£ç†äºº)",
                        use_container_width=True
                    ):
                        selected_group = group['agents']
        
        st.divider()
        
        # å€‹åˆ¥ä»£ç†äººé¸æ“‡
        st.write("**å€‹åˆ¥é¸æ“‡:**")
        
        # æŒ‰é¡åˆ¥åˆ†çµ„é¡¯ç¤º
        categories = {}
        for agent in self.agents:
            cat = agent.get('category', 'other')
            if cat not in categories:
                categories[cat] = []
            categories[cat].append(agent)
        
        selected_agents = []
        
        category_names = {
            'clinical': 'ğŸ¥ è‡¨åºŠè©•ä¼°',
            'engineering': 'âš¡ å·¥ç¨‹æŠ€è¡“',
            'software': 'ğŸ’» è»Ÿé«”é©—è­‰',
            'biological': 'ğŸ§¬ ç”Ÿç‰©å®‰å…¨',
            'quality': 'âš ï¸ å“è³ªç®¡ç†',
            'regulatory': 'ğŸ“‹ æ³•è¦ç¬¦åˆ'
        }
        
        for cat, agents_in_cat in categories.items():
            with st.expander(category_names.get(cat, cat), expanded=True):
                for agent in agents_in_cat:
                    col1, col2 = st.columns([3, 1])
                    
                    with col1:
                        selected = st.checkbox(
                            f"{agent['icon']} {agent['name']}",
                            value=False,
                            key=f"agent_select_{agent['id']}",
                            help=agent['role']
                        )
                        if selected:
                            selected_agents.append(agent['id'])
                    
                    with col2:
                        # é¡¯ç¤ºå„ªå…ˆç´š
                        st.caption(f"å„ªå…ˆç´š: {agent['priority']}")
        
        # è‹¥é¸æ“‡äº†ç¾¤çµ„,è¦†è“‹å€‹åˆ¥é¸æ“‡
        if selected_group:
            return selected_group
        
        return selected_agents
    
    async def execute_agents(
        self,
        agent_ids: List[str],
        context: str,
        execution_mode: str = 'parallel'
    ):
        """åŸ·è¡Œé¸å®šçš„ä»£ç†äºº"""
        
        # æ§‹å»ºåŸ·è¡Œè¨ˆç•«
        execution_plan = self._build_execution_plan(agent_ids, execution_mode)
        
        # åˆå§‹åŒ–é€²åº¦è¿½è¹¤
        progress_bar = st.progress(0)
        status_text = st.empty()
        
        total_agents = sum(len(batch) for batch in execution_plan)
        completed = 0
        
        # åŸ·è¡Œå„æ‰¹æ¬¡
        for batch_idx, batch in enumerate(execution_plan):
            status_text.text(f"åŸ·è¡Œæ‰¹æ¬¡ {batch_idx + 1}/{len(execution_plan)}")
            
            # å¹³è¡ŒåŸ·è¡ŒåŒæ‰¹æ¬¡çš„ä»£ç†äºº
            tasks = [
                self._execute_single_agent(agent_id, context)
                for agent_id in batch
            ]
            
            results = await asyncio.gather(*tasks, return_exceptions=True)
            
            # æ›´æ–°é€²åº¦
            completed += len(batch)
            progress_bar.progress(completed / total_agents)
        
        status_text.text("âœ… æ‰€æœ‰ä»£ç†äººåŸ·è¡Œå®Œç•¢")
        
        # è¿”å›çµæœ
        return self.agents
    
    def _build_execution_plan(
        self,
        agent_ids: List[str],
        mode: str
    ) -> List[List[str]]:
        """æ§‹å»ºåŸ·è¡Œè¨ˆç•«"""
        
        if mode == 'parallel':
            # å…¨éƒ¨å¹³è¡ŒåŸ·è¡Œ
            return [agent_ids]
        
        elif mode == 'sequential':
            # ä¾å„ªå…ˆç´šé †åºåŸ·è¡Œ
            sorted_agents = sorted(
                [a for a in self.agents if a['id'] in agent_ids],
                key=lambda x: x['priority']
            )
            return [[a['id']] for a in sorted_agents]
        
        elif mode == 'dependency':
            # æ ¹æ“šä¾è³´é—œä¿‚å»ºç«‹æ‰¹æ¬¡
            return self._resolve_dependencies(agent_ids)
        
        else:
            raise ValueError(f"ä¸æ”¯æ´çš„åŸ·è¡Œæ¨¡å¼: {mode}")
    
    def _resolve_dependencies(self, agent_ids: List[str]) -> List[List[str]]:
        """è§£æä¾è³´é—œä¿‚,å»ºç«‹åŸ·è¡Œæ‰¹æ¬¡"""
        from collections import defaultdict, deque
        
        # å»ºç«‹ä¾è³´åœ–
        graph = defaultdict(list)
        in_degree = {aid: 0 for aid in agent_ids}
        
        for agent_id in agent_ids:
            agent = next(a for a in self.agents if a['id'] == agent_id)
            deps = agent.get('dependencies', [])
            
            for dep in deps:
                if dep in agent_ids:
                    graph[dep].append(agent_id)
                    in_degree[agent_id] += 1
        
        # æ‹“æ’²æ’åº
        batches = []
        queue = deque([aid for aid, degree in in_degree.items() if degree == 0])
        
        while queue:
            current_batch = list(queue)
            batches.append(current_batch)
            queue.clear()
            
            for agent_id in current_batch:
                for neighbor in graph[agent_id]:
                    in_degree[neighbor] -= 1
                    if in_degree[neighbor] == 0:
                        queue.append(neighbor)
        
        return batches
    
    async def _execute_single_agent(
        self,
        agent_id: str,
        context: str
    ) -> Dict:
        """åŸ·è¡Œå–®ä¸€ä»£ç†äºº"""
        
        # æ‰¾åˆ°ä»£ç†äººå®šç¾©
        agent = next((a for a in self.agents if a['id'] == agent_id), None)
        if not agent:
            return {'success': False, 'error': 'Agent not found'}
        
        # æ›´æ–°ç‹€æ…‹
        agent['status'] = 'running'
        agent['start_time'] = datetime.now()
        
        # è¨˜éŒ„æ—¥èªŒ
        self._add_log(agent['name'], 'é–‹å§‹åŸ·è¡Œ...', 'info')
        
        try:
            # å‘¼å«Gemini API
            api_key = APIKeyManager().retrieve_api_key()
            genai.configure(api_key=api_key)
            
            model = genai.GenerativeModel(
                model_name='gemini-2.5-flash',
                generation_config=agent.get('generation_config', {}),
                safety_settings=agent.get('safety_settings', [])
            )
            
            # æ§‹å»ºå®Œæ•´æç¤ºè©
            full_prompt = f"{agent['system_prompt']}\n\n=== å¯©æŸ¥æ–‡ä»¶ ===\n{context}"
            
            # ç”Ÿæˆå…§å®¹
            response = await model.generate_content_async(full_prompt)
            
            # æ›´æ–°ä»£ç†äººç‹€æ…‹
            agent['status'] = 'completed'
            agent['output'] = response.text
            agent['token_usage'] = response.usage_metadata.total_token_count
            agent['end_time'] = datetime.now()
            
            self._add_log(agent['name'], 'åŸ·è¡Œå®Œæˆ', 'success')
            
            return {
                'success': True,
                'agent_id': agent_id,
                'output': response.text
            }
            
        except Exception as e:
            agent['status'] = 'failed'
            agent['error'] = str(e)
            agent['end_time'] = datetime.now()
            
            self._add_log(agent['name'], f'åŸ·è¡Œå¤±æ•—: {str(e)}', 'error')
            
            return {
                'success': False,
                'agent_id': agent_id,
                'error': str(e)
            }
    
    def _add_log(self, source: str, message: str, log_type: str):
        """æ·»åŠ æ—¥èªŒè¨˜éŒ„"""
        log_entry = {
            'timestamp': datetime.now(),
            'source': source,
            'message': message,
            'type': log_type
        }
        SessionManager.append('system_logs', log_entry)

7. Streamlitå¯¦ä½œæ¶æ§‹
7.1 å°ˆæ¡ˆçµæ§‹
Copytw-smartreview-2030/
â”œâ”€â”€ app.py                          # ä¸»æ‡‰ç”¨å…¥å£
â”œâ”€â”€ requirements.txt                # Pythonä¾è³´å¥—ä»¶
â”œâ”€â”€ .env                            # ç’°å¢ƒè®Šæ•¸(ä¸ç´å…¥ç‰ˆæ§)
â”œâ”€â”€ .streamlit/
â”‚   â””â”€â”€ config.toml                 # Streamlité…ç½®
â”œâ”€â”€ config/
â”‚   â”œâ”€â”€ agents.yaml                 # ä»£ç†äººå®šç¾©
â”‚   â”œâ”€â”€ painter_styles.yaml         # è¦–è¦ºé¢¨æ ¼å®šç¾©
â”‚   â””â”€â”€ regulatory_standards.yaml   # æ³•è¦æ¨™æº–è³‡æ–™åº«
â”œâ”€â”€ core/
â”‚   â”œâ”€â”€ session_manager.py          # Sessionç‹€æ…‹ç®¡ç†
â”‚   â”œâ”€â”€ orchestrator.py             # ä»£ç†äººç·¨æ’å™¨
â”‚   â””â”€â”€ security.py                 # å®‰å…¨æ€§æ¨¡çµ„
â”œâ”€â”€ services/
â”‚   â”œâ”€â”€ ocr_service.py              # OCRæœå‹™
â”‚   â”œâ”€â”€ gemini_service.py           # Gemini APIå°è£
â”‚   â””â”€â”€ vector_store.py             # å‘é‡è³‡æ–™åº«æœå‹™
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ file_processor.py           # æ–‡ä»¶è™•ç†å…ƒä»¶
â”‚   â”œâ”€â”€ agent_network_viz.py        # ä»£ç†äººç¶²çµ¡è¦–è¦ºåŒ–
â”‚   â”œâ”€â”€ terminal_log.py             # çµ‚ç«¯æ©Ÿæ—¥èªŒå…ƒä»¶
â”‚   â””â”€â”€ note_keeper.py              # æ™ºæ…§ç­†è¨˜å…ƒä»¶
â”œâ”€â”€ pages/
â”‚   â”œâ”€â”€ 1_ğŸ“Š_Dashboard.py           # å„€è¡¨æ¿é é¢
â”‚   â”œâ”€â”€ 2_ğŸ“¤_File_Upload.py         # æ–‡ä»¶ä¸Šå‚³é é¢
â”‚   â”œâ”€â”€ 3_ğŸ¤–_Agent_Execution.py     # ä»£ç†äººåŸ·è¡Œé é¢
â”‚   â”œâ”€â”€ 4_ğŸ“_Review_Results.py      # å¯©æŸ¥çµæœé é¢
â”‚   â”œâ”€â”€ 5_ğŸ¨_Style_Settings.py      # é¢¨æ ¼è¨­å®šé é¢
â”‚   â””â”€â”€ 6_â„¹ï¸_About.py               # é—œæ–¼é é¢
â”œâ”€â”€ utils/
â”‚   â”œâ”€â”€ logger.py                   # æ—¥èªŒå·¥å…·
â”‚   â”œâ”€â”€ validators.py               # è³‡æ–™é©—è­‰
â”‚   â””â”€â”€ helpers.py                  # è¼”åŠ©å‡½å¼
â”œâ”€â”€ assets/
â”‚   â”œâ”€â”€ images/                     # åœ–ç‰‡è³‡æº
â”‚   â”œâ”€â”€ fonts/                      # å­—é«”æª”æ¡ˆ
â”‚   â””â”€â”€ styles/
â”‚       â””â”€â”€ custom.css              # è‡ªå®šç¾©CSS
â””â”€â”€ tests/
    â”œâ”€â”€ test_orchestrator.py        # å–®å…ƒæ¸¬è©¦
    â””â”€â”€ test_ocr_service.py
7.2 ä¸»æ‡‰ç”¨å…¥å£
pythonCopy# app.py
import streamlit as st
from core.session_manager import SessionManager
from core.security import APIKeyManager
from utils.logger import setup_logger
import yaml

# è¨­å®šé é¢é…ç½®
st.set_page_config(
    page_title="TW-SmartReview 2030",
    page_icon="ğŸ¯",
    layout="wide",
    initial_sidebar_state="expanded",
    menu_items={
        'Get Help': 'https://github.com/your-repo',
        'Report a bug': 'https://github.com/your-repo/issues',
        'About': '# TW-SmartReview 2030\næ™ºæ…§åŒ–å¯©æŸ¥ä»£ç†äººç³»çµ±'
    }
)

# åˆå§‹åŒ–æ—¥èªŒ
logger = setup_logger()

# åˆå§‹åŒ–Session State
SessionManager.initialize()

# è¼‰å…¥è‡ªå®šç¾©CSS
def load_custom_css():
    with open('assets/styles/custom.css', 'r', encoding='utf-8') as f:
        st.markdown(f'<style>{f.read()}</style>', unsafe_allow_html=True)

load_custom_css()

# å¥—ç”¨è—è¡“é¢¨æ ¼
def apply_painter_style():
    current_style = SessionManager.get('current_painter_style', 'cyberpunk')
    
    with open('config/painter_styles.yaml', 'r', encoding='utf-8') as f:
        styles = yaml.safe_load(f)
    
    style_config = next(
        (s for s in styles['styles'] if s['id'] == current_style),
        styles['styles'][0]
    )
    
    # æ³¨å…¥å‹•æ…‹æ¨£å¼
    st.markdown(f"""
    <style>
    :root {{
        --bg-gradient: {style_config['bg']};
        --accent-color: {style_config['accent']};
        --font-family: {style_config['font']};
    }}
    
    .stApp {{
        background: var(--bg-gradient);
        font-family: var(--font-family);
    }}
    
    .glass-panel {{
        background: rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 12px;
        padding: 20px;
        box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
    }}
    </style>
    """, unsafe_allow_html=True)

apply_painter_style()

# å´é‚Šæ¬„
with st.sidebar:
    st.image('assets/images/logo.png', width=200)
    st.title("TW-SmartReview 2030")
    st.caption("v4.2.0 | Cinematic Release")
    
    st.divider()
    
    # API Keyè¨­å®š
    st.subheader("ğŸ”‘ APIé‡‘é‘°è¨­å®š")
    
    key_manager = APIKeyManager()
    existing_key = key_manager.retrieve_api_key()
    
    if existing_key:
        st.success("âœ… APIé‡‘é‘°å·²é…ç½®")
        if st.button("æ›´æ–°é‡‘é‘°"):
            SessionManager.set('api_key_configured', False)
            st.rerun()
    else:
        api_key_input = st.text_input(
            "Gemini API Key",
            type="password",
            help="è«‹è¼¸å…¥æ‚¨çš„Google Gemini APIé‡‘é‘°"
        )
        
        if st.button("å„²å­˜é‡‘é‘°"):
            if key_manager.validate_key(api_key_input):
                key_manager.store_api_key(api_key_input)
                st.success("âœ… é‡‘é‘°å·²å„²å­˜")
                st.rerun()
            else:
                st.error("âŒ é‡‘é‘°ç„¡æ•ˆ,è«‹æª¢æŸ¥å¾Œé‡è©¦")
    
    st.divider()
    
    # æ¨¡å‹é¸æ“‡
    st.subheader("ğŸ¤– æ¨¡å‹è¨­å®š")
    model_choice = st.selectbox(
        "é¸æ“‡AIæ¨¡å‹",
        options=[
            "gemini-2.5-flash",
            "gemini-2.5-flash-lite"
        ],
        index=0
    )
    SessionManager.set('selected_model', model_choice)
    
    st.divider()
    
    # ç³»çµ±ç‹€æ…‹
    st.subheader("ğŸ“Š ç³»çµ±ç‹€æ…‹")
    status = SessionManager.get('workflow_status', 'idle')
    status_emoji = {
        'idle': 'ğŸŸ¢',
        'processing': 'ğŸ”µ',
        'completed': 'ğŸŸ¢',
        'error': 'ğŸ”´'
    }
    st.info(f"{status_emoji[status]} {status.upper()}")
    
    # æ´»èºä»£ç†äººæ•¸
    active_agents = SessionManager.get('active_agents', [])
    running_agents = [a for a in active_agents if a['status'] == 'running']
    st.metric("æ´»èºä»£ç†äºº", len(running_agents))
    
    st.divider()
    
    # å¿«é€Ÿé€£çµ
    st.subheader("ğŸ”— å¿«é€Ÿé€£çµ")
    st.page_link("pages/1_ğŸ“Š_Dashboard.py", label="å„€è¡¨æ¿")
    st.page_link("pages/2_ğŸ“¤_File_Upload.py", label="æ–‡ä»¶ä¸Šå‚³")
    st.page_link("pages/3_ğŸ¤–_Agent_Execution.py", label="ä»£ç†äººåŸ·è¡Œ")
    st.page_link("pages/4_ğŸ“_Review_Results.py", label="å¯©æŸ¥çµæœ")

# ä¸»é é¢å…§å®¹
st.title("ğŸ¯ æ­¡è¿ä½¿ç”¨ TW-SmartReview 2030")

col1, col2 = st.columns(2)

with col1:
    st.markdown("""
    ### ğŸš€ ç³»çµ±ç‰¹è‰²
    
    - **æ™ºæ…§åŒ–**: é‹ç”¨æœ€å…ˆé€²çš„AIæ¨¡å‹é€²è¡Œæ–‡ä»¶ç†è§£èˆ‡åˆ†æ
    - **è‡ªå‹•åŒ–**: æ‰¹æ¬¡è™•ç†å¤šä»½æ–‡ä»¶,å¤§å¹…æå‡å¯©æŸ¥æ•ˆç‡
    - **é€æ˜åŒ–**: æ‰€æœ‰æ¨ç†éç¨‹å¯è¿½æº¯,ç¬¦åˆç›£ç®¡è¦æ±‚
    - **å”åŒåŒ–**: å¤šä»£ç†äººå”ä½œ,æ¨¡æ“¬è·¨éƒ¨é–€å¯©æŸ¥åœ˜éšŠ
    - **éš±ç§å„ªå…ˆ**: ç„¡å¾Œç«¯æ¶æ§‹,è³‡æ–™ä¸é›¢é–‹æœ¬åœ°ç«¯
    """)

with col2:
    st.markdown("""
    ### ğŸ“‹ å¿«é€Ÿé–‹å§‹
    
    1. **è¨­å®šAPIé‡‘é‘°**: åœ¨å´é‚Šæ¬„è¼¸å…¥æ‚¨çš„Gemini API Key
    2. **ä¸Šå‚³æ–‡ä»¶**: å‰å¾€ã€Œæ–‡ä»¶ä¸Šå‚³ã€é é¢
    3. **é¸æ“‡ä»£ç†äºº**: åœ¨ã€Œä»£ç†äººåŸ·è¡Œã€é é¢é¸æ“‡å¯©æŸ¥é …ç›®
    4. **æŸ¥çœ‹çµæœ**: åœ¨ã€Œå¯©æŸ¥çµæœã€é é¢æª¢è¦–å ±å‘Š
    """)

st.divider()

# ç³»çµ±æ¶æ§‹åœ–
st.subheader("ğŸ—ï¸ ç³»çµ±æ¶æ§‹")

with st.expander("æŸ¥çœ‹æ¶æ§‹åœ–", expanded=False):
    st.image('assets/images/architecture_diagram.png', use_column_width=True)

# æœ€æ–°å‹•æ…‹
st.subheader("ğŸ“¢ æœ€æ–°å‹•æ…‹")

news_items = [
    {"date": "2025-12-15", "title": "v4.2.0 Cinematic Releaseç™¼å¸ƒ", "type": "release"},
    {"date": "2025-12-10", "title": "æ–°å¢å€å¡Šéˆç¨½æ ¸è»Œè·¡åŠŸèƒ½", "type": "feature"},
    {"date": "2025-12-05", "title": "æ”¯æ´å¤šåœ‹æ³•è¦å”èª¿æ¨¡çµ„", "type": "feature"},
]

for item in news_items:
    badge_color = "blue" if item['type'] == 'release' else "green"
    st.markdown(f"""
    <div class="glass-panel" style="margin-bottom: 10px;">
        <span style="color: gray;">{item['date']}</span>
        <span style="background: {badge_color}; color: white; padding: 2px 8px; border-radius: 4px; margin-left: 10px;">{item['type'].upper()}</span>
        <br>
        <strong>{item['title']}</strong>
    </div>
    """, unsafe_allow_html=True)

# Footer
st.divider()
st.caption("Â© 2025 TW-SmartReview 2030 Project | Powered by Google Gemini AI")
7.3 è‡ªå®šç¾©CSSæ¨£å¼
cssCopy/* assets/styles/custom.css */

/* ç»ç’ƒæ“¬æ…‹é¢æ¿ */
.glass-panel {
    background: rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 12px;
    padding: 20px;
    box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
    transition: all 0.3s ease;
}

.glass-panel:hover {
    transform: translateY(-2px);
    box-shadow: 0 12px 40px 0 rgba(0, 0, 0, 0.45);
}

/* çµ‚ç«¯æ©Ÿæ—¥èªŒæ¨£å¼ */
.terminal-log {
    background: #1e1e1e;
    color: #00ff00;
    font-family: 'Courier New', monospace;
    padding: 15px;
    border-radius: 8px;
    height: 400px;
    overflow-y: auto;
    font-size: 13px;
    line-height: 1.5;
}

.log-entry {
    margin-bottom: 5px;
}

.log-timestamp {
    color: #888;
}

.log-source {
    color: #00bfff;
    font-weight: bold;
}

.log-info {
    color: #00ff00;
}

.log-success {
    color: #32cd32;
}

.log-warning {
    color: #ffa500;
}

.log-error {
    color: #ff4500;
}

.log-system {
    color: #1e90ff;
}

/* ç‹€æ…‹æŒ‡ç¤ºå™¨å‹•ç•« */
@keyframes pulse {
    0%, 100% {
        opacity: 1;
    }
    50% {
        opacity: 0.5;
    }
}

.status-indicator {
    width: 12px;
    height: 12px;
    border-radius: 50%;
    display: inline-block;
    animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
}

.status-operational {
    background-color: #10b981;
}
