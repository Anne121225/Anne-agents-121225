TW-SmartReview 2030 æ™ºæ…§åŒ–å¯©æŸ¥ä»£ç†äººç³»çµ±æŠ€è¡“è¦æ ¼æ›¸
TW-SmartReview 2030 Agentic System Technical Specifications
ç‰ˆæœ¬ï¼š v4.2.0 (Cinematic Release)
æ—¥æœŸï¼š 2025å¹´12æœˆ15æ—¥
æ©Ÿå¯†ç­‰ç´šï¼š å…§éƒ¨æŠ€è¡“æ–‡ä»¶
æäº¤å–®ä½ï¼š æ™ºæ…§é†«ç™‚æ³•è¦ç§‘å­¸å°ˆæ¡ˆç ”ç©¶å°çµ„æŠ€è¡“é–‹ç™¼éƒ¨

ç›®éŒ„

å°ˆæ¡ˆæ¦‚è¿°
ç³»çµ±æ¶æ§‹è¨­è¨ˆ
æ ¸å¿ƒåŠŸèƒ½æ¨¡çµ„è©³è§£
UIUXè¨­è¨ˆç³»çµ±
AIæ¨¡å‹æ•´åˆç­–ç•¥
è³‡æ–™çµæ§‹èˆ‡å‹åˆ¥å®šç¾©
Streamlitå¯¦ä½œæ¶æ§‹
agentsyamlé…ç½®ç³»çµ±
FDAå°ˆç”¨é€²éšåŠŸèƒ½æ¨¡çµ„
ç³»çµ±æ•ˆèƒ½å„ªåŒ–èˆ‡æ“´å±•æ€§
éƒ¨ç½²èˆ‡ç¶­é‹
çµè«–èˆ‡æœªä¾†å±•æœ›


1. å°ˆæ¡ˆæ¦‚è¿°
1.1 ç³»çµ±å®šä½èˆ‡é¡˜æ™¯
TW-SmartReview 2030 æ˜¯ä¸€å€‹å°ˆç‚ºè¡›ç”Ÿç¦åˆ©éƒ¨é£Ÿå“è—¥ç‰©ç®¡ç†ç½²(TFDA)ä»¥åŠç¾åœ‹é£Ÿå“è—¥ç‰©ç®¡ç†å±€(FDA)è¨­è¨ˆçš„æ¬¡ä¸–ä»£æ™ºæ…§å¯©æŸ¥ç³»çµ±ã€‚æœ¬ç³»çµ±æ¡ç”¨ä»£ç†å‹äººå·¥æ™ºæ…§(Agentic AI)æ¶æ§‹,é€éå¤šå€‹å°ˆè·AIä»£ç†äººçš„å”åŒé‹ä½œ,å¯¦ç¾é†«ç™‚å™¨ææŸ¥é©—ç™»è¨˜æ–‡ä»¶çš„è‡ªå‹•åŒ–è§£æã€æ³•è¦ç¬¦åˆæ€§æª¢æŸ¥ã€é¢¨éšªè©•ä¼°ä»¥åŠç§‘å­¸å¯©æŸ¥ç­‰è¤‡é›œä»»å‹™ã€‚
åœ¨ç•¶å‰é†«ç™‚å™¨æç”¢æ¥­å¿«é€Ÿç™¼å±•çš„èƒŒæ™¯ä¸‹,å¯©æŸ¥æ©Ÿé—œé¢è‡¨è‘—æ–‡ä»¶æ•¸é‡çˆ†ç‚¸æ€§å¢é•·ã€æŠ€è¡“è¤‡é›œåº¦æå‡ä»¥åŠå¯©æŸ¥æ¨™æº–åœ‹éš›åŒ–ç­‰å¤šé‡æŒ‘æˆ°ã€‚å‚³çµ±çš„äººå·¥å¯©æŸ¥æ¨¡å¼å·²é›£ä»¥æ»¿è¶³æ•ˆç‡èˆ‡å“è³ªçš„é›™é‡è¦æ±‚ã€‚TW-SmartReview 2030 é€éå¼•å…¥å…ˆé€²çš„å¤§å‹èªè¨€æ¨¡å‹(LLM)æŠ€è¡“èˆ‡å¤šä»£ç†äººå”ä½œæ©Ÿåˆ¶,åœ¨ä¿æŒå¯©æŸ¥åš´è¬¹æ€§çš„åŒæ™‚,å¤§å¹…æå‡è™•ç†æ•ˆç‡,å¯¦ç¾ã€Œæ™ºæ…§å¢å¼·å‹å¯©æŸ¥ã€(AI-Augmented Review)çš„å‰µæ–°æ¨¡å¼ã€‚
1.2 æ ¸å¿ƒè¨­è¨ˆç†å¿µ
æœ¬ç³»çµ±å»ºç«‹åœ¨äº”å¤§æ ¸å¿ƒæ”¯æŸ±ä¹‹ä¸Š:
1.2.1 æ™ºæ…§åŒ–(Intelligence)
é‹ç”¨Google Gemini 2.5 Flashç­‰æœ€å…ˆé€²çš„å¤šæ¨¡æ…‹å¤§å‹èªè¨€æ¨¡å‹,ç³»çµ±èƒ½å¤ :

è‡ªå‹•ç†è§£è¤‡é›œçš„é†«ç™‚å™¨ææŠ€è¡“æ–‡ä»¶,åŒ…æ‹¬æƒæå¼PDFã€æ‰‹å¯«è¨»è¨˜ç­‰éçµæ§‹åŒ–å…§å®¹
è­˜åˆ¥é—œéµè³‡è¨Šç‰‡æ®µ,å¦‚è‡¨åºŠè©¦é©—çµ‚é»ã€é›»æ°£å®‰å…¨åƒæ•¸ã€ç”Ÿç‰©ç›¸å®¹æ€§æ¸¬è©¦çµæœ
é€éçŸ¥è­˜åœ–è­œèˆ‡å‘é‡æª¢ç´¢æŠ€è¡“,å¿«é€Ÿå®šä½ç›¸é—œæ³•è¦æ¢æ–‡èˆ‡æ­·å²æ¡ˆä¾‹
é€²è¡Œå¤šæ­¥é©Ÿæ¨ç†,è©•ä¼°æ–‡ä»¶é‚è¼¯ä¸€è‡´æ€§èˆ‡æ•¸æ“šæ”¯æ’å……åˆ†æ€§

1.2.2 è‡ªå‹•åŒ–(Automation)
é€éå·¥ä½œæµç¨‹ç·¨æ’(Workflow Orchestration)æŠ€è¡“,ç³»çµ±èƒ½å¤ :

è‡ªå‹•åˆ†é…å¯©æŸ¥ä»»å‹™è‡³å°ˆè²¬ä»£ç†äºº,ç„¡éœ€äººå·¥èª¿åº¦
æ‰¹æ¬¡è™•ç†å¤šä»½æ–‡ä»¶,æ”¯æ´å„ªå…ˆç´šæ’ç¨‹èˆ‡ä¾è³´éˆç®¡ç†
è‡ªå‹•ç”Ÿæˆçµæ§‹åŒ–å¯©æŸ¥å ±å‘Š,åŒ…å«æ‘˜è¦ã€ç™¼ç¾äº‹é …ã€å»ºè­°æ”¹å–„æªæ–½
æ•´åˆé›»å­ç°½æ ¸ç³»çµ±,å¯¦ç¾ç«¯åˆ°ç«¯çš„ç„¡ç´™åŒ–ä½œæ¥­æµç¨‹

1.2.3 é€æ˜åŒ–(Transparency)
ç‚ºç¬¦åˆç›£ç®¡ç§‘å­¸(Regulatory Science)çš„åš´è¬¹è¦æ±‚,ç³»çµ±ç¢ºä¿:

æ‰€æœ‰AIæ¨ç†éç¨‹å‡å¯è¿½æº¯,æä¾›æ±ºç­–ä¾æ“šèˆ‡åƒè€ƒè³‡æ–™ä¾†æº
å¯¦ä½œå€å¡Šéˆç¨½æ ¸è»Œè·¡,è¨˜éŒ„æ¯ä¸€æ¬¡æ–‡ä»¶ä¿®æ”¹ã€å¯©æŸ¥æ„è¦‹èˆ‡æ ¸å‡†å‹•ä½œ
æ”¯æ´ã€Œå¯è§£é‡‹AIã€(Explainable AI, XAI)æŠ€è¡“,å°‡é»‘ç®±æ¨¡å‹çš„åˆ¤æ–·é‚è¼¯è¦–è¦ºåŒ–
æä¾›å®Œæ•´çš„æ“ä½œæ—¥èªŒèˆ‡æ™‚é–“æˆ³è¨˜,ç¬¦åˆFDA 21 CFR Part 11é›»å­è¨˜éŒ„è¦æ±‚

1.2.4 å”åŒåŒ–(Collaboration)
æ¨¡æ“¬çœŸå¯¦ä¸–ç•Œè·¨éƒ¨é–€å¯©æŸ¥åœ˜éšŠçš„é‹ä½œæ¨¡å¼:

å®šç¾©å¤šå€‹å°ˆæ¥­é ˜åŸŸä»£ç†äºº(è‡¨åºŠè©•ä¼°ã€é›»æ°£å®‰å…¨ã€è»Ÿé«”é©—è­‰ã€ç”Ÿç‰©ç›¸å®¹æ€§ç­‰)
é€éä¸­å¤®ç·¨æ’å™¨(Orchestrator)å”èª¿ä»£ç†äººé–“çš„è³‡è¨Šå‚³éèˆ‡ä»»å‹™ä¾è³´
æ”¯æ´äººæ©Ÿå”ä½œ(Human-in-the-Loop),é—œéµæ±ºç­–é»ä¿ç•™äººå·¥å¯©æ ¸
æ•´åˆå³æ™‚é€šè¨Šèˆ‡å”ä½œå·¥å…·,ä¿ƒé€²å¯©æŸ¥å“¡ã€å» å•†èˆ‡æŠ€è¡“å°ˆå®¶çš„æºé€š

1.2.5 éš±ç§å„ªå…ˆ(Privacy-First)
æ¡ç”¨å…ˆé€²çš„éš±ç§ä¿è­·æŠ€è¡“:

ç„¡å¾Œç«¯æ¶æ§‹(Backendless Architecture)
æ”¯æ´è¯é‚¦å­¸ç¿’(Federated Learning)
å¯¦ä½œå·®åˆ†éš±ç§(Differential Privacy)
ç¬¦åˆGDPRã€HIPAAç­‰åœ‹éš›éš±ç§æ³•è¦è¦æ±‚

1.3 ç›®æ¨™ä½¿ç”¨è€…ç¾¤é«”
æœ¬ç³»çµ±è¨­è¨ˆæ™‚å……åˆ†è€ƒé‡ä¸åŒä½¿ç”¨è€…è§’è‰²çš„éœ€æ±‚:
ä½¿ç”¨è€…é¡å‹ä¸»è¦éœ€æ±‚ç³»çµ±åŠŸèƒ½æ”¯æ´TFDA/FDAå¯©æŸ¥å“¡æå‡å¯©æŸ¥æ•ˆç‡ã€ç¢ºä¿ä¸€è‡´æ€§ã€æ¸›å°‘äººç‚ºç–æ¼è‡ªå‹•åŒ–åˆå¯©ã€æ™ºæ…§æ¯”å°ã€é¢¨éšªåˆ†ç´šã€å ±å‘Šç”Ÿæˆé†«æè£½é€ å•†æ³•è¦äººå“¡é€å¯©å‰è‡ªæˆ‘æª¢æŸ¥ã€é™ä½è£œä»¶ç‡ã€ç¸®çŸ­å¯©æŸ¥é€±æœŸPre-submission Reviewã€ç¼ºé™·åµæ¸¬ã€æ³•è¦æŒ‡å¼•ç¬¬ä¸‰æ–¹æŸ¥é©—é¡§å•å°ˆæ¥­æœå‹™å·¥å…·ã€æå‡æœå‹™å“è³ªã€æ“´å¤§æœå‹™é‡èƒ½æ‰¹æ¬¡è™•ç†ã€å®¢è£½åŒ–å ±å‘Šã€å¤šå°ˆæ¡ˆç®¡ç†å­¸è¡“ç ”ç©¶æ©Ÿæ§‹æ•™å­¸æ¡ˆä¾‹ã€ç ”ç©¶ç´ æã€æ³•è¦ç§‘å­¸ç™¼å±•åŒ¿ååŒ–æ¡ˆä¾‹åº«ã€çµ±è¨ˆåˆ†æã€è¶¨å‹¢è¦–è¦ºåŒ–
1.4 æŠ€è¡“å‰µæ–°äº®é»
ç›¸è¼ƒæ–¼å‚³çµ±çš„æ–‡ä»¶ç®¡ç†ç³»çµ±æˆ–ç°¡å–®çš„é—œéµå­—æœå°‹å·¥å…·,TW-SmartReview 2030å…·å‚™ä»¥ä¸‹çªç ´æ€§å‰µæ–°:

å¤šæ¨¡æ…‹æ–‡ä»¶ç†è§£,æ›´èƒ½ç†è§£åœ–è¡¨ã€æµç¨‹åœ–ã€é›»è·¯åœ–ç­‰è¦–è¦ºå…ƒç´ 
å‹•æ…‹ä»£ç†äººç·¨æ’
é›»å½±ç´šäº’å‹•ä»‹é¢,æä¾›æ²‰æµ¸å¼ä½¿ç”¨è€…é«”é©—
è—è¡“é¢¨æ ¼å¼•æ“+ç¨®è¦–è¦ºä¸»é¡Œ,å€‹æ€§åŒ–å·¥ä½œç’°å¢ƒ
Streamlitå¿«é€ŸåŸå‹


2. ç³»çµ±æ¶æ§‹è¨­è¨ˆ
2.1 æ•´é«”æ¶æ§‹æ¦‚è¦½
TW-SmartReview 2030æ¡ç”¨å¾®æœå‹™å°å‘æ¶æ§‹(Microservices-Oriented Architecture)çµåˆäº‹ä»¶é©…å‹•è¨­è¨ˆ(Event-Driven Design),å¯¦ç¾é«˜åº¦æ¨¡çµ„åŒ–èˆ‡å¯æ“´å±•æ€§ã€‚ç³»çµ±ç”±ä»¥ä¸‹æ ¸å¿ƒå±¤ç´šçµ„æˆ:
Copyâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    ä½¿ç”¨è€…ä»‹é¢å±¤ (UI Layer)                â”‚
â”‚          Streamlit Web App + Custom Components          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                   æ‡‰ç”¨é‚è¼¯å±¤ (Logic Layer)                â”‚
â”‚    Session State Management + Workflow Orchestration    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                   ä»£ç†äººåŸ·è¡Œå±¤ (Agent Layer)              â”‚
â”‚  Clinical Evaluator | Electrical Safety | Risk Analyzer â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                   AIæ¨è«–å±¤ (Inference Layer)              â”‚
â”‚        Google Gemini API + Vector Database (Pinecone)    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                   è³‡æ–™å­˜å–å±¤ (Data Layer)                 â”‚
â”‚    File Storage + Knowledge Base + Audit Trail (SQLite) â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
2.2 StreamlitæŠ€è¡“å †ç–Š
æœ¬ç³»çµ±é¸æ“‡Streamlitä½œç‚ºå‰ç«¯æ¡†æ¶,ç›¸è¼ƒæ–¼å‚³çµ±çš„React/Vue.jsç­‰JavaScriptæ¡†æ¶,å…·å‚™ä»¥ä¸‹å„ªå‹¢:
2.2.1 æ ¸å¿ƒå„ªå‹¢

ç´”Pythoné–‹ç™¼,é™ä½æŠ€è¡“æ£§è¤‡é›œåº¦
å³æ™‚ç†±é‡è¼‰,æ¥µè‡´é–‹ç™¼é«”é©—
å…§å»ºå…ƒä»¶è±å¯Œã€åœ–è¡¨ã€å¤šåª’é«”å…ƒä»¶é–‹ç®±å³ç”¨
Session Stateç®¡ç†
åŸç”Ÿæ”¯æ´è³‡æ–™ç§‘å­¸å¥—ä»¶ã€NumPyã€Plotlyç­‰

2.2.2 æŠ€è¡“å †ç–Šæ¸…å–®
é¡åˆ¥æŠ€è¡“/å¥—ä»¶ç‰ˆæœ¬ç”¨é€”æ ¸å¿ƒæ¡†æ¶Streamlit1.32.0+Webæ‡‰ç”¨æ¡†æ¶èªè¨€Python3.11+ä¸»è¦é–‹ç™¼èªè¨€AIæ¨è«–google-generativeai0.4.0+Gemini APIå®¢æˆ¶ç«¯æ–‡ä»¶è™•ç†PyMuPDF (fitz)1.23.0+PDFè§£æèˆ‡æ¸²æŸ“å‘é‡æª¢ç´¢pinecone-client3.0.0+å‘é‡è³‡æ–™åº«å®¢æˆ¶ç«¯è³‡æ–™è™•ç†pandas2.2.0+çµæ§‹åŒ–è³‡æ–™æ“ä½œè¦–è¦ºåŒ–plotly5.18.0+äº’å‹•å¼åœ–è¡¨é…ç½®ç®¡ç†PyYAML6.0+YAMLæª”æ¡ˆè§£ææ—¥èªŒè¨˜éŒ„loguru0.7.0+çµæ§‹åŒ–æ—¥èªŒç’°å¢ƒè®Šæ•¸python-dotenv1.0.0+ç’°å¢ƒé…ç½®ç®¡ç†
2.3 è³‡æ–™æµæ¶æ§‹
ç³»çµ±æ¡ç”¨å–®å‘è³‡æ–™æµ(Unidirectional Data Flow)è¨­è¨ˆæ¨¡å¼,ç¢ºä¿ç‹€æ…‹è®ŠåŒ–çš„å¯é æ¸¬æ€§:
pythonCopy# è³‡æ–™æµå‘ç¤ºæ„
ä½¿ç”¨è€…ä¸Šå‚³æ–‡ä»¶ 
    â†“
æ–‡ä»¶å‰è™•ç†å™¨(Preprocessor)
    â†“
LLM-OCRæœå‹™(OCR Service)
    â†“
Contextæå–èˆ‡å­˜å„²(Session State)
    â†“
ä»£ç†äººç·¨æ’å™¨(Orchestrator)
    â†“
å¹³è¡Œ/åºåˆ—åŸ·è¡Œä»£ç†äºº(Agents Execution)
    â†“
çµæœèšåˆå™¨(Result Aggregator)
    â†“
UIå³æ™‚æ›´æ–°(Real-time UI Update)
2.3.1 Session Stateç®¡ç†ç­–ç•¥
Streamlitçš„æ ¸å¿ƒæ©Ÿåˆ¶æ˜¯åœ¨æ¯æ¬¡ä½¿ç”¨è€…äº’å‹•æ™‚é‡æ–°åŸ·è¡Œæ•´å€‹è…³æœ¬ã€‚ç‚ºé¿å…ç‹€æ…‹ä¸Ÿå¤±èˆ‡é‡è¤‡é‹ç®—,ç³»çµ±å¯¦ä½œä»¥ä¸‹ç­–ç•¥:
pythonCopy# core/session_manager.py
import streamlit as st
from typing import Any, Optional

class SessionManager:
    """é›†ä¸­å¼Session Stateç®¡ç†å™¨"""
    
    @staticmethod
    def initialize():
        """åˆå§‹åŒ–æ‰€æœ‰å¿…è¦çš„sessionè®Šæ•¸"""
        defaults = {
            'processed_documents': [],
            'active_agents': [],
            'review_results': {},
            'system_logs': [],
            'current_painter_style': 'cyberpunk',
            'api_key_configured': False,
            'user_notes': '',
            'workflow_status': 'idle'  # idle, processing, completed, error
        }
        
        for key, value in defaults.items():
            if key not in st.session_state:
                st.session_state[key] = value
    
    @staticmethod
    def get(key: str, default: Any = None) -> Any:
        """å®‰å…¨åœ°ç²å–sessionè®Šæ•¸"""
        return st.session_state.get(key, default)
    
    @staticmethod
    def set(key: str, value: Any):
        """è¨­å®šsessionè®Šæ•¸"""
        st.session_state[key] = value
    
    @staticmethod
    def append(key: str, value: Any):
        """å‘åˆ—è¡¨é¡å‹çš„sessionè®Šæ•¸è¿½åŠ å…ƒç´ """
        if key not in st.session_state:
            st.session_state[key] = []
        st.session_state[key].append(value)
2.4 å®‰å…¨æ€§æ¶æ§‹
2.4.1 å¤šå±¤é˜²ç¦¦ç­–ç•¥
ç³»çµ±å¯¦ä½œç¸±æ·±é˜²ç¦¦(Defense in Depth)å®‰å…¨æ¨¡å‹:
Copyâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Layer 1: ç¶²è·¯å±¤é˜²è­·                 â”‚
â”‚  - HTTPSå¼·åˆ¶åŠ å¯†                    â”‚
â”‚  - Rate Limiting (APIé–˜é“)          â”‚
â”‚  - DDoSé˜²è­· (Cloudflare)            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Layer 2: æ‡‰ç”¨å±¤é˜²è­·                 â”‚
â”‚  - API KeyåŠ å¯†å­˜å„²                  â”‚
â”‚  - Session Tokené©—è­‰                â”‚
â”‚  - CSRF Tokenä¿è­·                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Layer 3: è³‡æ–™å±¤é˜²è­·                 â”‚
â”‚  - æ•æ„Ÿè³‡æ–™åŠ å¯† (AES-256)           â”‚
â”‚  - å­˜å–æ§åˆ¶åˆ—è¡¨ (ACL)               â”‚
â”‚  - ç¨½æ ¸æ—¥èªŒ (Immutable Log)         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Layer 4: åˆè¦æ€§æ§åˆ¶                 â”‚
â”‚  - GDPRè³‡æ–™ä¸»é«”æ¬Šåˆ©                 â”‚
â”‚  - HIPAAå­˜å–å¯©è¨ˆ                    â”‚
â”‚  - FDA 21 CFR Part 11é›»å­ç°½ç«        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
2.4.2 API Keyç®¡ç†å¯¦ä½œ
pythonCopy# core/security.py
import os
from cryptography.fernet import Fernet
from typing import Optional

class APIKeyManager:
    """APIé‡‘é‘°å®‰å…¨ç®¡ç†å™¨"""
    
    def __init__(self):
        # å¾ç’°å¢ƒè®Šæ•¸æˆ–ä½¿ç”¨è€…ä¸»å¯†ç¢¼æ´¾ç”ŸåŠ å¯†é‡‘é‘°
        self.cipher_suite = self._initialize_cipher()
    
    def _initialize_cipher(self) -> Fernet:
        """åˆå§‹åŒ–åŠ å¯†å™¨"""
        # å„ªå…ˆä½¿ç”¨ç’°å¢ƒè®Šæ•¸ä¸­çš„åŠ å¯†é‡‘é‘°
        encryption_key = os.getenv('ENCRYPTION_KEY')
        if not encryption_key:
            # è‹¥ç„¡ç’°å¢ƒè®Šæ•¸,ä½¿ç”¨ç¡¬é«”æŒ‡ç´‹+é¹½å€¼ç”Ÿæˆ
            encryption_key = Fernet.generate_key()
        return Fernet(encryption_key)
    
    def store_api_key(self, api_key: str) -> bool:
        """åŠ å¯†ä¸¦å­˜å„²APIé‡‘é‘°"""
        try:
            encrypted_key = self.cipher_suite.encrypt(api_key.encode())
            # åƒ…å­˜æ–¼session state,ä¸å¯«å…¥ç£ç¢Ÿ
            SessionManager.set('encrypted_api_key', encrypted_key)
            SessionManager.set('api_key_configured', True)
            return True
        except Exception as e:
            st.error(f"é‡‘é‘°å­˜å„²å¤±æ•—: {str(e)}")
            return False
    
    def retrieve_api_key(self) -> Optional[str]:
        """è§£å¯†ä¸¦å–å¾—APIé‡‘é‘°"""
        encrypted_key = SessionManager.get('encrypted_api_key')
        if not encrypted_key:
            # å˜—è©¦å¾ç’°å¢ƒè®Šæ•¸è®€å–
            return os.getenv('GEMINI_API_KEY')
        
        try:
            decrypted_key = self.cipher_suite.decrypt(encrypted_key)
            return decrypted_key.decode()
        except Exception:
            return None
    
    def validate_key(self, api_key: str) -> bool:
        """é©—è­‰APIé‡‘é‘°æœ‰æ•ˆæ€§"""
        # é€²è¡Œæ¸¬è©¦æ€§APIå‘¼å«
        try:
            import google.generativeai as genai
            genai.configure(api_key=api_key)
            model = genai.GenerativeModel('gemini-2.5-flash')
            # ç™¼é€æ¥µç°¡æ¸¬è©¦è«‹æ±‚
            response = model.generate_content("Test")
            return True
        except Exception as e:
            st.warning(f"APIé‡‘é‘°é©—è­‰å¤±æ•—: {str(e)}")
            return False

3. æ ¸å¿ƒåŠŸèƒ½æ¨¡çµ„è©³è§£
3.1 æ™ºæ…§å„€è¡¨æ¿æ¨¡çµ„
3.1.1 æ¨¡çµ„æ¶æ§‹
æ™ºæ…§å„€è¡¨æ¿ä½æ–¼æ‡‰ç”¨ç¨‹å¼é¦–é ,æä¾›ç³»çµ±ç‹€æ…‹çš„å…¨æ™¯è¦–åœ–èˆ‡é—œéµæŒ‡æ¨™ç›£æ§ã€‚
pythonCopy# pages/1_ğŸ“Š_Dashboard.py
import streamlit as st
import plotly.express as px
import plotly.graph_objects as go
from datetime import datetime, timedelta
import pandas as pd

def render_dashboard():
    """æ¸²æŸ“æ™ºæ…§å„€è¡¨æ¿"""
    st.set_page_config(
        page_title="TW-SmartReview 2030 å„€è¡¨æ¿",
        page_icon="ğŸ“Š",
        layout="wide"
    )
    
    # å¥—ç”¨ç•¶å‰è—è¡“é¢¨æ ¼
    apply_painter_style(SessionManager.get('current_painter_style'))
    
    # æ¨™é¡Œå€
    col1, col2 = st.columns([3, 1])
    with col1:
        st.title("ğŸ¯ TW-SmartReview 2030 æ™ºæ…§å„€è¡¨æ¿")
        st.caption(f"æœ€å¾Œæ›´æ–°: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    
    with col2:
        # ç³»çµ±ç‹€æ…‹æŒ‡ç¤ºå™¨
        status = SessionManager.get('workflow_status')
        status_color = {
            'idle': 'ğŸŸ¢',
            'processing': 'ğŸ”µ', 
            'completed': 'ğŸŸ¢',
            'error': 'ğŸ”´'
        }
        st.metric(
            label="ç³»çµ±ç‹€æ…‹",
            value=status_color.get(status, 'âšª') + " " + status.upper()
        )
    
    # é—œéµæŒ‡æ¨™å¡ç‰‡å€
    render_kpi_cards()
    
    # åœ–è¡¨å€
    render_charts()
    
    # æ´»èºä»£ç†äººç¶²çµ¡è¦–è¦ºåŒ–
    render_agent_network()

def render_kpi_cards():
    """æ¸²æŸ“é—œéµç¸¾æ•ˆæŒ‡æ¨™å¡ç‰‡"""
    col1, col2, col3, col4 = st.columns(4)
    
    # æ¨¡æ“¬æ•¸æ“š (å¯¦éš›æ‡‰å¾è³‡æ–™åº«æˆ–session stateå–å¾—)
    metrics = {
        'æœ¬æœˆå¯©æŸ¥æ¡ˆä»¶': (124, +12),
        'å¹³å‡å¯©æŸ¥æ™‚é•·': ('3.2å¤©', -0.5),
        'å¯©æŸ¥é€šéç‡': ('87%', +3),
        'AI Tokenä½¿ç”¨': ('2.3M', +150000)
    }
    
    with col1:
        st.metric(
            label="ğŸ“ æœ¬æœˆå¯©æŸ¥æ¡ˆä»¶",
            value=metrics['æœ¬æœˆå¯©æŸ¥æ¡ˆä»¶'][0],
            delta=f"+{metrics['æœ¬æœˆå¯©æŸ¥æ¡ˆä»¶'][1]} è¼ƒä¸Šæœˆ"
        )
    
    with col2:
        st.metric(
            label="â±ï¸ å¹³å‡å¯©æŸ¥æ™‚é•·",
            value=metrics['å¹³å‡å¯©æŸ¥æ™‚é•·'][0],
            delta=f"{metrics['å¹³å‡å¯©æŸ¥æ™‚é•·'][1]}å¤© è¼ƒä¸Šæœˆ",
            delta_color="inverse"  # æ•¸å€¼æ¸›å°‘æ˜¯å¥½äº‹
        )
    
    with col3:
        st.metric(
            label="âœ… å¯©æŸ¥é€šéç‡",
            value=metrics['å¯©æŸ¥é€šéç‡'][0],
            delta=f"+{metrics['å¯©æŸ¥é€šéç‡'][1]}% è¼ƒä¸Šæœˆ"
        )
    
    with col4:
        st.metric(
            label="ğŸ¤– AI Tokenä½¿ç”¨",
            value=metrics['AI Tokenä½¿ç”¨'][0],
            delta=f"+{metrics['AI Tokenä½¿ç”¨'][1]} è¼ƒä¸Šæœˆ"
        )

def render_charts():
    """æ¸²æŸ“çµ±è¨ˆåœ–è¡¨"""
    tab1, tab2, tab3 = st.tabs(["ğŸ“ˆ å¯©æŸ¥è¶¨å‹¢", "ğŸ“Š æ¡ˆä»¶åˆ†å¸ƒ", "ğŸ¯ æ•ˆç‡åˆ†æ"])
    
    with tab1:
        # æ™‚é–“åºåˆ—è¶¨å‹¢åœ–
        df_trend = generate_trend_data()
        fig = px.area(
            df_trend,
            x='æ—¥æœŸ',
            y=['é€ä»¶æ•¸', 'å®Œæˆå¯©æŸ¥æ•¸'],
            title='è¿‘30æ—¥å¯©æŸ¥è¶¨å‹¢',
            labels={'value': 'æ¡ˆä»¶æ•¸', 'variable': 'é¡åˆ¥'}
        )
        st.plotly_chart(fig, use_container_width=True)
    
    with tab2:
        # æ¡ˆä»¶åˆ†é¡åœ“é¤…åœ–
        df_category = pd.DataFrame({
            'å™¨æé¡åˆ¥': ['è¨ºæ–·è©¦åŠ‘', 'æ¤å…¥ç‰©', 'é«”å¤–å¾ªç’°', 'é›»æ°£è¨­å‚™', 'è»Ÿé«”'],
            'æ¡ˆä»¶æ•¸': [45, 32, 18, 23, 6]
        })
        fig = px.pie(
            df_category,
            values='æ¡ˆä»¶æ•¸',
            names='å™¨æé¡åˆ¥',
            title='æœ¬æœˆæ¡ˆä»¶é¡åˆ¥åˆ†å¸ƒ'
        )
        st.plotly_chart(fig, use_container_width=True)
    
    with tab3:
        # å¯©æŸ¥æ•ˆç‡å°æ¯”é•·æ¢åœ–
        df_efficiency = pd.DataFrame({
            'å¯©æŸ¥éšæ®µ': ['æ–‡ä»¶æ¥æ”¶', 'åˆæ­¥å¯©æŸ¥', 'AIè¼”åŠ©åˆ†æ', 'å°ˆå®¶è¤‡æ ¸', 'æœ€çµ‚æ ¸å®š'],
            'äººå·¥å¯©æŸ¥(å°æ™‚)': [2, 48, 0, 24, 8],
            'AIè¼”åŠ©å¯©æŸ¥(å°æ™‚)': [1, 12, 4, 16, 6]
        })
        fig = go.Figure(data=[
            go.Bar(name='äººå·¥å¯©æŸ¥', x=df_efficiency['å¯©æŸ¥éšæ®µ'], y=df_efficiency['äººå·¥å¯©æŸ¥(å°æ™‚)']),
            go.Bar(name='AIè¼”åŠ©å¯©æŸ¥', x=df_efficiency['å¯©æŸ¥éšæ®µ'], y=df_efficiency['AIè¼”åŠ©å¯©æŸ¥(å°æ™‚)'])
        ])
        fig.update_layout(barmode='group', title='å¯©æŸ¥æµç¨‹æ•ˆç‡å°æ¯”')
        st.plotly_chart(fig, use_container_width=True)
3.1.2 å‹•æ…‹ä»£ç†äººç¶²çµ¡è¦–è¦ºåŒ–
ä½¿ç”¨Plotlyå»ºç«‹å³æ™‚æ›´æ–°çš„ä»£ç†äººé€£æ¥åœ–:
pythonCopydef render_agent_network():
    """æ¸²æŸ“ä»£ç†äººç¥ç¶“ç¶²çµ¡è¦–è¦ºåŒ–"""
    st.subheader("ğŸ•¸ï¸ ä»£ç†äººå”ä½œç¶²çµ¡")
    
    active_agents = SessionManager.get('active_agents', [])
    
    if not active_agents:
        st.info("å°šç„¡æ´»èºä»£ç†äººã€‚è«‹å…ˆä¸Šå‚³æ–‡ä»¶ä¸¦å•Ÿå‹•å¯©æŸ¥æµç¨‹ã€‚")
        return
    
    # æ§‹å»ºç¶²çµ¡åœ–è³‡æ–™
    import networkx as nx
    
    G = nx.Graph()
    
    # æ·»åŠ ä¸­å¿ƒç¯€é»
    G.add_node("Orchestrator", node_type="hub")
    
    # æ·»åŠ ä»£ç†äººç¯€é»
    for agent in active_agents:
        G.add_node(
            agent['id'],
            node_type="agent",
            status=agent['status'],
            name=agent['name']
        )
        # é€£æ¥è‡³ä¸­å¿ƒç¯€é»
        G.add_edge("Orchestrator", agent['id'])
    
    # æ·»åŠ ä»£ç†äººé–“çš„ä¾è³´é—œä¿‚
    for agent in active_agents:
        for dep in agent.get('dependencies', []):
            if dep in [a['id'] for a in active_agents]:
                G.add_edge(agent['id'], dep, edge_type="dependency")
    
    # è¨ˆç®—ä½ˆå±€
    pos = nx.spring_layout(G, k=0.5, iterations=50)
    
    # æº–å‚™Plotlyè³‡æ–™
    edge_trace = []
    for edge in G.edges():
        x0, y0 = pos[edge[0]]
        x1, y1 = pos[edge[1]]
        edge_trace.append(
            go.Scatter(
                x=[x0, x1, None],
                y=[y0, y1, None],
                mode='lines',
                line=dict(width=2, color='#888'),
                hoverinfo='none'
            )
        )
    
    node_trace = go.Scatter(
        x=[],
        y=[],
        text=[],
        mode='markers+text',
        hoverinfo='text',
        marker=dict(
            size=[],
            color=[],
            line=dict(width=2, color='white')
        ),
        textposition="top center"
    )
    
    status_colors = {
        'idle': '#gray',
        'running': '#3b82f6',
        'completed': '#10b981',
        'failed': '#ef4444'
    }
    
    for node in G.nodes():
        x, y = pos[node]
        node_trace['x'] += tuple([x])
        node_trace['y'] += tuple([y])
        
        if node == "Orchestrator":
            node_trace['marker']['size'] += tuple([40])
            node_trace['marker']['color'] += tuple(['#8b5cf6'])
            node_trace['text'] += tuple(['ğŸ¯ Orchestrator'])
        else:
            agent_data = next((a for a in active_agents if a['id'] == node), None)
            if agent_data:
                node_trace['marker']['size'] += tuple([30])
                node_trace['marker']['color'] += tuple([status_colors.get(agent_data['status'], '#gray')])
                node_trace['text'] += tuple([agent_data['name']])
    
    # çµ„åˆåœ–è¡¨
    fig = go.Figure(
        data=edge_trace + [node_trace],
        layout=go.Layout(
            showlegend=False,
            hovermode='closest',
            margin=dict(b=0, l=0, r=0, t=0),
            xaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
            yaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
            plot_bgcolor='rgba(0,0,0,0)',
            height=500
        )
    )
    
    st.plotly_chart(fig, use_container_width=True)
    
    # ä»£ç†äººç‹€æ…‹è¡¨æ ¼
    st.dataframe(
        pd.DataFrame([
            {
                'ä»£ç†äºº': a['name'],
                'ç‹€æ…‹': a['status'],
                'é–‹å§‹æ™‚é–“': a.get('start_time', 'N/A'),
                'Tokenä½¿ç”¨': a.get('token_usage', 0)
            }
            for a in active_agents
        ]),
        use_container_width=True
    )
3.2 æ–‡ä»¶è™•ç†æ¨¡çµ„
3.2.1 å¤šæ ¼å¼æ–‡ä»¶æ”å–å™¨
pythonCopy# components/file_processor.py
import streamlit as st
import PyMuPDF as fitz  # PyMuPDF
from PIL import Image
import io
from typing import List, Dict, Optional

class FileProcessor:
    """å¤šæ ¼å¼æ–‡ä»¶è™•ç†å™¨"""
    
    SUPPORTED_FORMATS = {
        'application/pdf': 'PDF',
        'text/plain': 'TXT',
        'text/markdown': 'Markdown',
        'application/json': 'JSON',
        'image/png': 'PNG',
        'image/jpeg': 'JPEG',
        'image/tiff': 'TIFF'
    }
    
    MAX_FILE_SIZE = 50 * 1024 * 1024  # 50MB
    
    @staticmethod
    def render_uploader():
        """æ¸²æŸ“æ–‡ä»¶ä¸Šå‚³ä»‹é¢"""
        st.subheader("ğŸ“¤ æ–‡ä»¶ä¸Šå‚³")
        
        uploaded_files = st.file_uploader(
            "æ”¯æ´æ ¼å¼: PDF, TXT, Markdown, JSON, PNG, JPG, TIFF",
            type=['pdf', 'txt', 'md', 'json', 'png', 'jpg', 'jpeg', 'tiff'],
            accept_multiple_files=True,
            help="å–®æª”æœ€å¤§50MB,ç¸½è¨ˆæœ€å¤§200MB"
        )
        
        if uploaded_files:
            return FileProcessor._process_files(uploaded_files)
        return None
    
    @staticmethod
    def _process_files(files: List) -> List[Dict]:
        """è™•ç†ä¸Šå‚³çš„æ–‡ä»¶"""
        processed_docs = []
        
        progress_bar = st.progress(0)
        status_text = st.empty()
        
        for idx, file in enumerate(files):
            status_text.text(f"è™•ç†ä¸­: {file.name} ({idx+1}/{len(files)})")
            
            # æª¢æŸ¥æª”æ¡ˆå¤§å°
            if file.size > FileProcessor.MAX_FILE_SIZE:
                st.warning(f"âš ï¸ {file.name} è¶…éå¤§å°é™åˆ¶(50MB),å·²è·³é")
                continue
            
            # æ ¹æ“šMIMEé¡å‹è™•ç†
            if file.type == 'application/pdf':
                doc_data = FileProcessor._process_pdf(file)
            elif file.type.startswith('image/'):
                doc_data = FileProcessor._process_image(file)
            elif file.type in ['text/plain', 'text/markdown']:
                doc_data = FileProcessor._process_text(file)
            elif file.type == 'application/json':
                doc_data = FileProcessor._process_json(file)
            else:
                st.error(f"âŒ ä¸æ”¯æ´çš„æª”æ¡ˆæ ¼å¼: {file.type}")
                continue
            
            if doc_data:
                processed_docs.append(doc_data)
            
            progress_bar.progress((idx + 1) / len(files))
        
        status_text.text(f"âœ… å®Œæˆè™•ç† {len(processed_docs)} ä»½æ–‡ä»¶")
        return processed_docs
    
    @staticmethod
    def _process_pdf(file) -> Optional[Dict]:
        """è™•ç†PDFæª”æ¡ˆ"""
        try:
            pdf_bytes = file.read()
            pdf_document = fitz.open(stream=pdf_bytes, filetype="pdf")
            
            # é ç¢¼ç¯„åœé¸æ“‡
            total_pages = pdf_document.page_count
            st.info(f"ğŸ“„ æª”æ¡ˆ {file.name} å…± {total_pages} é ")
            
            page_range = st.text_input(
                f"é¸æ“‡é ç¢¼ç¯„åœ (ä¾‹: 1-5, 10, 15-20)",
                value=f"1-{total_pages}",
                key=f"page_range_{file.name}"
            )
            
            selected_pages = FileProcessor._parse_page_range(page_range, total_pages)
            
            # æå–æ–‡å­—èˆ‡åœ–ç‰‡
            extracted_text = ""
            images = []
            
            for page_num in selected_pages:
                page = pdf_document[page_num - 1]  # 0-indexed
                extracted_text += page.get_text()
                
                # æå–åœ–ç‰‡
                image_list = page.get_images()
                for img_index, img in enumerate(image_list):
                    xref = img[0]
                    base_image = pdf_document.extract_image(xref)
                    images.append({
                        'page': page_num,
                        'index': img_index,
                        'data': base_image["image"]
                    })
            
            pdf_document.close()
            
            return {
                'filename': file.name,
                'type': 'pdf',
                'total_pages': total_pages,
                'selected_pages': selected_pages,
                'text': extracted_text,
                'images': images,
                'size': file.size,
                'upload_time': datetime.now()
            }
            
        except Exception as e:
            st.error(f"PDFè™•ç†å¤±æ•—: {str(e)}")
            return None
    
    @staticmethod
    def _parse_page_range(range_str: str, total_pages: int) -> List[int]:
        """è§£æé ç¢¼ç¯„åœå­—ä¸²"""
        pages = set()
        parts = range_str.split(',')
        
        for part in parts:
            part = part.strip()
            if '-' in part:
                start, end = part.split('-')
                start = int(start.strip())
                end = int(end.strip())
                pages.update(range(start, min(end, total_pages) + 1))
            else:
                page = int(part)
                if 1 <= page <= total_pages:
                    pages.add(page)
        
        return sorted(list(pages))
3.2.2 LLM-OCRæœå‹™
pythonCopy# services/ocr_service.py
import google.generativeai as genai
from typing import Dict, Optional
import base64

class LLMOCRService:
    """åŸºæ–¼LLMçš„å…‰å­¸å­—å…ƒè¾¨è­˜æœå‹™"""
    
    def __init__(self, api_key: str):
        genai.configure(api_key=api_key)
        self.model = genai.GenerativeModel('gemini-2.5-flash')
    
    async def extract_text_from_pdf(
        self,
        pdf_bytes: bytes,
        page_range: Optional[str] = None,
        language: str = 'zh-TW'
    ) -> Dict:
        """å¾PDFæå–æ–‡å­—"""
        
        # å°‡PDFè½‰æ›ç‚ºbase64
        pdf_base64 = base64.b64encode(pdf_bytes).decode('utf-8')
        
        prompt = self._build_ocr_prompt(page_range, language)
        
        try:
            response = await self.model.generate_content_async([
                {
                    'mime_type': 'application/pdf',
                    'data': pdf_base64
                },
                prompt
            ])
            
            return {
                'success': True,
                'text': response.text,
                'token_count': response.usage_metadata.total_token_count,
                'method': 'llm-ocr'
            }
            
        except Exception as e:
            return {
                'success': False,
                'error': str(e),
                'method': 'llm-ocr'
            }
    
    def _build_ocr_prompt(self, page_range: Optional[str], language: str) -> str:
        """æ§‹å»ºOCRæç¤ºè©"""
        return f"""
ä½ æ˜¯ä¸€å€‹å°ˆæ¥­çš„é†«ç™‚å™¨ææ–‡ä»¶å…‰å­¸å­—å…ƒè¾¨è­˜ç³»çµ±ã€‚

ã€ä»»å‹™ã€‘
å¾æä¾›çš„PDFæ–‡ä»¶ä¸­æå–æ‰€æœ‰æ–‡å­—å…§å®¹ã€‚

ã€è¦æ±‚ã€‘
1. ä¿æŒåŸå§‹æ’ç‰ˆçµæ§‹(æ¨™é¡Œã€æ®µè½ã€æ¸…å–®ã€è¡¨æ ¼)
2. ç²¾ç¢ºè¾¨è­˜å°ˆæ¥­è¡“èª(é†«ç™‚å™¨æåç¨±ã€æ³•è¦ç·¨è™Ÿã€æ¸¬è©¦æ¨™æº–)
3. å°æ–¼è¡¨æ ¼,ä½¿ç”¨Markdownè¡¨æ ¼æ ¼å¼è¼¸å‡º
4. å°æ–¼æ¨¡ç³Šæˆ–ç„¡æ³•è¾¨è­˜çš„æ–‡å­—,æ¨™è¨»ç‚º[UNCLEAR]
5. ä¿ç•™æ–‡ä»¶ä¸­çš„å¤šèªè¨€å…§å®¹(ä¸­è‹±æ–‡æ··åˆ)

{f'ã€è™•ç†ç¯„åœã€‘åƒ…è™•ç†ç¬¬ {page_range} é ' if page_range else 'ã€è™•ç†ç¯„åœã€‘è™•ç†æ‰€æœ‰é é¢'}

ã€è¼¸å‡ºèªè¨€ã€‘{language}

ã€è¼¸å‡ºæ ¼å¼ã€‘ç´”Markdownæ–‡å­—,ä¸è¦åŒ…å«ä»»ä½•é¡å¤–èªªæ˜

é–‹å§‹æå–:
"""
3.3 ä»£ç†äººç·¨æ’æ¨¡çµ„
3.3.1 agents.yamlé…ç½®æª”æ¡ˆ
ç³»çµ±çš„ä»£ç†äººå®šç¾©å®Œå…¨é€éYAMLé…ç½®æª”æ¡ˆé€²è¡Œç®¡ç†:
yamlCopy# config/agents.yaml
meta:
  version: "4.2.0"
  last_updated: "2025-12-15"
  description: "TW-SmartReview 2030 ä»£ç†äººé…ç½®æª”æ¡ˆ"

agents:
  - id: clinical-evaluator
    name: è‡¨åºŠè©•ä¼°å°ˆå®¶
    name_en: Clinical Evaluation Specialist
    role: è©•ä¼°è‡¨åºŠè©¦é©—æ•¸æ“šçš„å®Œæ•´æ€§èˆ‡ç§‘å­¸æ€§
    category: clinical
    icon: "ğŸ¥"
    priority: 1
    enabled: true
    dependencies: []
    
    system_prompt: |
      ä½ æ˜¯ä¸€ä½æ“æœ‰15å¹´ç¶“é©—çš„è‡¨åºŠè©•ä¼°å°ˆå®¶,å°ˆç²¾æ–¼é†«ç™‚å™¨æè‡¨åºŠè©¦é©—è©•ä¼°ã€‚
      
      ã€ä½ çš„ä»»å‹™ã€‘
      å¯©æŸ¥è‡¨åºŠè©¦é©—æ–‡ä»¶,è©•ä¼°å…¶ç§‘å­¸æ€§ã€å®Œæ•´æ€§èˆ‡æ³•è¦ç¬¦åˆæ€§ã€‚
      
      ã€è©•ä¼°é‡é»ã€‘
      1. æ¨£æœ¬æ•¸è¨ˆç®—çš„åˆç†æ€§(çµ±è¨ˆæª¢å®šåŠ›åˆ†æ)
      2. ä¸»è¦çµ‚é»(Primary Endpoint)èˆ‡æ¬¡è¦çµ‚é»çš„é¸æ“‡é©ç•¶æ€§
      3. çµ±è¨ˆæ–¹æ³•çš„æ­£ç¢ºæ€§(ITTåˆ†æã€Per-protocolåˆ†æ)
      4. ä¸è‰¯äº‹ä»¶å ±å‘Šçš„å®Œæ•´æ€§èˆ‡å› æœé—œä¿‚åˆ¤å®š
      5. çŸ¥æƒ…åŒæ„æµç¨‹çš„åˆè¦æ€§
      6. è©¦é©—è¨­è¨ˆçš„åå·®æ§åˆ¶(ç›²æ³•ã€éš¨æ©ŸåŒ–)
      
      ã€è¼¸å‡ºæ ¼å¼ã€‘
      # è‡¨åºŠè©•ä¼°å ±å‘Š
      
      ## åŸ·è¡Œæ‘˜è¦
      [ç°¡è¦æ¦‚è¿°ä¸»è¦ç™¼ç¾]
      
      ## è©¦é©—è¨­è¨ˆè©•ä¼°
      - **è©¦é©—é¡å‹**: [RCT/å–®è‡‚/è§€å¯Ÿæ€§]
      - **æ¨£æœ¬æ•¸**: [å¯¦éš›/è¨ˆç•«] 
      - **ä¸»è¦çµ‚é»**: [æè¿°]
      - **è©•ä¼°**: [PASS/FAIL/éœ€è£œå……è³‡æ–™]
      
      ## æ•¸æ“šå®Œæ•´æ€§æª¢æŸ¥
      [è©³ç´°åˆ†æ]
      
      ## ä¸è‰¯äº‹ä»¶åˆ†æ
      [äº‹ä»¶æ¸…å–®èˆ‡åš´é‡ç¨‹åº¦è©•ä¼°]
      
      ## æ³•è¦ç¬¦åˆæ€§
      - ISO 14155ç¬¦åˆåº¦: [%]
      - GCPç¬¦åˆåº¦: [%]
      
      ## å»ºè­°äº‹é …
      1. [å»ºè­°1]
      2. [å»ºè­°2]
      
      ## é¢¨éšªç­‰ç´š
      [LOW/MEDIUM/HIGH/CRITICAL]
      
    generation_config:
      max_output_tokens: 4096
      temperature: 0.3
      top_p: 0.9
      top_k: 40
    
    safety_settings:
      - category: HARM_CATEGORY_MEDICAL_ADVICE
        threshold: BLOCK_MEDIUM_AND_ABOVE
  
  - id: electrical-safety
    name: é›»æ°£å®‰å…¨å¯©æŸ¥å“¡
    name_en: Electrical Safety Reviewer
    role: æª¢æŸ¥é›»æ°£å®‰å…¨æ¨™æº–ç¬¦åˆæ€§
    category: engineering
    icon: "âš¡"
    priority: 2
    enabled: true
    dependencies: []
    
    system_prompt: |
      ä½ æ˜¯ä¸€ä½é›»æ°£å®‰å…¨å·¥ç¨‹å¸«,å°ˆç²¾æ–¼IEC 60601-1æ¨™æº–ã€‚
      
      ã€ä½ çš„ä»»å‹™ã€‘
      å¯©æŸ¥é†«ç™‚é›»æ°£è¨­å‚™çš„å®‰å…¨æ€§è¨­è¨ˆæ–‡ä»¶ã€‚
      
      ã€æª¢æŸ¥é …ç›®ã€‘
      1. é›»æ°£çµ•ç·£ç­‰ç´š(å·¥ä½œé›»å£“ã€çµ•ç·£è€å£“æ¸¬è©¦)
      2. æ¼é›»æµé™å€¼(æ¥åœ°æ¼é›»æµã€å¤–æ®¼æ¼é›»æµã€æ‚£è€…æ¼é›»æµ)
      3. ä¿è­·æ¥åœ°ç³»çµ±å®Œæ•´æ€§
      4. EMCé›»ç£ç›¸å®¹æ€§(IEC 60601-1-2)
      5. é›»æ± å®‰å…¨æ€§(éå……/éæ”¾ä¿è­·)
      6. æ¨™ç¤ºèˆ‡è­¦èªå®Œæ•´æ€§
      
      ã€åƒè€ƒæ¨™æº–ã€‘
      - IEC 60601-1:2005+AMD1:2012+AMD2:2020
      - IEC 60601-1-2:2014 (EMC)
      - IEC 60601-1-6:2010 (Usability)
      
      ã€è¼¸å‡ºæ ¼å¼ã€‘
      # é›»æ°£å®‰å…¨å¯©æŸ¥å ±å‘Š
      
      ## å™¨æåˆ†é¡
      - **é˜²é›»æ“Šç­‰ç´š**: [Class I/II/III]
      - **æ‡‰ç”¨éƒ¨åˆ†**: [B/BF/CFå‹]
      
      ## ç¬¦åˆæ€§æª¢æŸ¥è¡¨
      | é …ç›® | è¦æ±‚å€¼ | å¯¦æ¸¬å€¼ | åˆ¤å®š |
      |------|--------|--------|------|
      | æ¥åœ°æ¼é›»æµ | <500ÂµA | [æ•¸å€¼] | [âœ“/âœ—] |
      
      ## é¢¨éšªè©•ä¼°
      [è­˜åˆ¥çš„é¢¨éšªé»]
      
      ## å»ºè­°æªæ–½
      [æ”¹å–„å»ºè­°]
  
  - id: software-verification
    name: è»Ÿé«”é©—è­‰å°ˆå®¶
    name_en: Software Verification Specialist
    role: è©•ä¼°è»Ÿé«”ç”Ÿå‘½é€±æœŸæ–‡ä»¶èˆ‡é©—è­‰æ¸¬è©¦
    category: software
    icon: "ğŸ’»"
    priority: 3
    enabled: true
    dependencies: []
    
    system_prompt: |
      ä½ æ˜¯ä¸€ä½é†«ç™‚è»Ÿé«”é©—è­‰å°ˆå®¶,å°ˆç²¾æ–¼IEC 62304æ¨™æº–ã€‚
      
      ã€ä½ çš„ä»»å‹™ã€‘
      å¯©æŸ¥é†«ç™‚å™¨æè»Ÿé«”(SaMD/SiMD)çš„é–‹ç™¼èˆ‡é©—è­‰æ–‡ä»¶ã€‚
      
      ã€è©•ä¼°é‡é»ã€‘
      1. è»Ÿé«”å®‰å…¨åˆ†é¡(Class A/B/C)çš„åˆç†æ€§
      2. è»Ÿé«”éœ€æ±‚è¦æ ¼(SRS)çš„å®Œæ•´æ€§èˆ‡å¯è¿½æº¯æ€§
      3. è»Ÿé«”è¨­è¨ˆæ–‡ä»¶(SDD)çš„æ¶æ§‹åˆç†æ€§
      4. å–®å…ƒæ¸¬è©¦ã€æ•´åˆæ¸¬è©¦ã€ç³»çµ±æ¸¬è©¦çš„è¦†è“‹ç‡
      5. é¢¨éšªç®¡ç†æª”æ¡ˆ(ä¾ISO 14971)
      6. ç¶²è·¯å®‰å…¨è€ƒé‡(FDA Cybersecurity Guidance)
      
      ã€è¼¸å‡ºæ ¼å¼ã€‘
      # è»Ÿé«”é©—è­‰å ±å‘Š
      
      ## è»Ÿé«”æè¿°
      - **SOUPå…ƒä»¶**: [ç¬¬ä¸‰æ–¹è»Ÿé«”æ¸…å–®]
      - **å®‰å…¨ç­‰ç´š**: [A/B/C]
      
      ## éœ€æ±‚è¿½æº¯çŸ©é™£æª¢æŸ¥
      [éœ€æ±‚â†’è¨­è¨ˆâ†’æ¸¬è©¦çš„å¯è¿½æº¯æ€§]
      
      ## æ¸¬è©¦è¦†è“‹ç‡åˆ†æ
      - ç¨‹å¼ç¢¼è¦†è“‹ç‡: [%]
      - éœ€æ±‚è¦†è“‹ç‡: [%]
      
      ## ç¶²è·¯å®‰å…¨è©•ä¼°
      [æ¼æ´æƒæçµæœã€åŠ å¯†æ©Ÿåˆ¶æª¢æŸ¥]
      
      ## ç¬¦åˆæ€§çµè«–
      [æ˜¯å¦ç¬¦åˆIEC 62304è¦æ±‚]
  
  - id: biocompatibility
    name: ç”Ÿç‰©ç›¸å®¹æ€§è©•ä¼°å¸«
    name_en: Biocompatibility Assessor
    role: è©•ä¼°ç”Ÿç‰©å®‰å…¨æ€§æ¸¬è©¦æ•¸æ“š
    category: biological
    icon: "ğŸ§¬"
    priority: 4
    enabled: true
    dependencies: []
    
    system_prompt: |
      ä½ æ˜¯ä¸€ä½ç”Ÿç‰©ç›¸å®¹æ€§è©•ä¼°å°ˆå®¶,å°ˆç²¾æ–¼ISO 10993ç³»åˆ—æ¨™æº–ã€‚
      
      ã€ä½ çš„ä»»å‹™ã€‘
      æ ¹æ“šå™¨æçš„æ¥è§¸æ€§è³ªèˆ‡æŒçºŒæ™‚é–“,è©•ä¼°æ‰€éœ€çš„ç”Ÿç‰©ç›¸å®¹æ€§æ¸¬è©¦é …ç›®èˆ‡çµæœã€‚
      
      ã€è©•ä¼°æµç¨‹ã€‘
      1. åˆ¤å®šå™¨æçš„æ¥è§¸é¡åˆ¥(è¡¨é¢æ¥è§¸/å¤–éƒ¨é€£é€š/æ¤å…¥)
      2. åˆ¤å®šæ¥è§¸æ™‚é–“(æš«æ™‚/çŸ­æœŸ/é•·æœŸ)
      3. ä¾ISO 10993-1æ±ºå®šå¿…è¦æ¸¬è©¦é …ç›®
      4. å¯©æŸ¥æ¸¬è©¦å ±å‘Šçš„å®Œæ•´æ€§èˆ‡åˆæ ¼æ€§
      
      ã€æ¸¬è©¦é …ç›®å°ç…§ã€‘
      - ç´°èƒæ¯’æ€§(ISO 10993-5)
      - è‡´æ•æ€§(ISO 10993-10)
      - åˆºæ¿€æ€§(ISO 10993-10)
      - å…¨èº«æ¯’æ€§(ISO 10993-11)
      - æ¤å…¥åæ‡‰(ISO 10993-6)
      - éºå‚³æ¯’æ€§(ISO 10993-3)
      - è¡€æ¶²ç›¸å®¹æ€§(ISO 10993-4)
      - è‡´ç™Œæ€§(ISO 10993-3)
      
      ã€è¼¸å‡ºæ ¼å¼ã€‘
      # ç”Ÿç‰©ç›¸å®¹æ€§è©•ä¼°å ±å‘Š
      
      ## å™¨æè³‡è¨Š
      - **æ¥è§¸é¡åˆ¥**: [é¡åˆ¥]
      - **æ¥è§¸æ™‚é–“**: [æ™‚é–“]
      
      ## æ‰€éœ€æ¸¬è©¦é …ç›®æ¸…å–®
      | æ¸¬è©¦é …ç›® | ISOæ¨™æº– | è¦æ±‚ | ç‹€æ…‹ |
      |----------|---------|------|------|
      
      ## æ¸¬è©¦çµæœè©•ä¼°
      [å„é …æ¸¬è©¦çš„é€šé/å¤±æ•—åˆ¤å®š]
      
      ## ææ–™å®‰å…¨æ€§çµè«–
      [æ•´é«”ç”Ÿç‰©ç›¸å®¹æ€§è©•ä¼°çµè«–]
  
  - id: risk-manager
    name: é¢¨éšªç®¡ç†å°ˆå®¶
    name_en: Risk Management Specialist
    role: åŸ·è¡ŒISO 14971é¢¨éšªåˆ†æ
    category: quality
    icon: "âš ï¸"
    priority: 5
    enabled: true
    dependencies:
      - clinical-evaluator
      - electrical-safety
      - software-verification
      - biocompatibility
    
    system_prompt: |
      ä½ æ˜¯ä¸€ä½é¢¨éšªç®¡ç†å°ˆå®¶,å°ˆç²¾æ–¼ISO 14971:2019æ¨™æº–ã€‚
      
      ã€ä½ çš„ä»»å‹™ã€‘
      æ•´åˆæ‰€æœ‰å°ˆæ¥­é ˜åŸŸä»£ç†äººçš„ç™¼ç¾,é€²è¡Œç¶œåˆé¢¨éšªè©•ä¼°ã€‚
      
      ã€é¢¨éšªåˆ†ææ–¹æ³•ã€‘
      1. æ”¶é›†æ‰€æœ‰å·²è­˜åˆ¥çš„å±å®³(Hazards)
      2. åˆ†æå±å®³æƒ…å¢ƒ(Hazardous Situations)
      3. ä¼°è¨ˆé¢¨éšª(Severity Ã— Probability)
      4. è©•ä¼°é¢¨éšªå¯æ¥å—æ€§
      5. å»ºè­°é¢¨éšªæ§åˆ¶æªæ–½
      6. è©•ä¼°æ®˜é¤˜é¢¨éšª
      
      ã€é¢¨éšªçŸ©é™£ã€‘
      åš´é‡åº¦: 1(å¯å¿½ç•¥) ~ 5(ç½é›£æ€§)
      ç™¼ç”Ÿæ©Ÿç‡: A(æ¥µç½•è¦‹) ~ E(é »ç¹)
      
      ã€è¼¸å‡ºæ ¼å¼ã€‘
      # ç¶œåˆé¢¨éšªç®¡ç†å ±å‘Š
      
      ## é¢¨éšªå½™ç¸½è¡¨
      | é¢¨éšªID | å±å®³æè¿° | åš´é‡åº¦ | æ©Ÿç‡ | é¢¨éšªç­‰ç´š | æ§åˆ¶æªæ–½ |
      |--------|----------|--------|------|----------|----------|
      
      ## é«˜é¢¨éšªé …ç›®è©³ç´°åˆ†æ
      [é‡å°é«˜é¢¨éšªé …ç›®çš„æ·±å…¥æ¢è¨]
      
      ## é¢¨éšª/æ•ˆç›Šåˆ†æ
      [æ®˜é¤˜é¢¨éšªæ˜¯å¦å¯æ¥å—]
      
      ## ä¸Šå¸‚å¾Œç›£æ§è¨ˆç•«å»ºè­°
      [å»ºè­°çš„PMSç›£æ¸¬é …ç›®]
  
  - id: regulatory-mapper
    name: æ³•è¦æ™ºæ…§æ¯”å°å¼•æ“
    name_en: Regulatory Intelligence Mapper
    role: æ¯”å°å¤šåœ‹æ³•è¦è¦æ±‚
    category: regulatory
    icon: "ğŸ“‹"
    priority: 6
    enabled: true
    dependencies: []
    
    system_prompt: |
      ä½ æ˜¯ä¸€ä½åœ‹éš›æ³•è¦å°ˆå®¶,ç†Ÿæ‚‰TFDAã€FDAã€CEã€PMDAç­‰å¤šåœ‹æ³•è¦è¦æ±‚ã€‚
      
      ã€ä½ çš„ä»»å‹™ã€‘
      æ¯”å°é€å¯©æ–‡ä»¶èˆ‡ç›®æ¨™å¸‚å ´çš„æ³•è¦è¦æ±‚,è­˜åˆ¥ç¼ºå£ã€‚
      
      ã€æ³•è¦è³‡æ–™åº«ã€‘
      - TFDA: é†«ç™‚å™¨æç®¡ç†è¾¦æ³•ã€æŸ¥é©—ç™»è¨˜å¯©æŸ¥æº–å‰‡
      - FDA: 510(k), PMA, De Novo pathways
      - EU MDR: Regulation (EU) 2017/745
      - Japan PMDA: PMD Act
      
      ã€è¼¸å‡ºæ ¼å¼ã€‘
      # æ³•è¦ç¬¦åˆæ€§æ¯”å°å ±å‘Š
      
      ## ç›®æ¨™å¸‚å ´åˆ†æ
      - **ä¸»è¦å¸‚å ´**: [TFDA/FDA/CE]
      - **å™¨æåˆ†é¡**: [å„å¸‚å ´çš„åˆ†é¡]
      
      ## æ³•è¦è¦æ±‚å°ç…§è¡¨
      | è¦æ±‚é …ç›® | TFDA | FDA | EU MDR | ç¬¦åˆç‹€æ…‹ |
      |----------|------|-----|--------|----------|
      
      ## ç¼ºå£åˆ†æ
      [ç¼ºå°‘çš„æ–‡ä»¶æˆ–æ¸¬è©¦]
      
      ## é€å¯©ç­–ç•¥å»ºè­°
      [å„ªå…ˆç”³è«‹å¸‚å ´ã€åŒæ­¥é€å¯©å¯è¡Œæ€§]

# ä»£ç†äººç¾¤çµ„å®šç¾©
agent_groups:
  - id: essential-review
    name: åŸºæœ¬å¯©æŸ¥çµ„
    description: æ‰€æœ‰æ¡ˆä»¶çš„å¿…è¦å¯©æŸ¥é …ç›®
    agents:
      - clinical-evaluator
      - electrical-safety
      - biocompatibility
      - risk-manager
  
  - id: software-intensive
    name: è»Ÿé«”å¯†é›†å¯©æŸ¥çµ„
    description: è»Ÿé«”ç‚ºä¸»è¦åŠŸèƒ½çš„å™¨æ
    agents:
      - clinical-evaluator
      - software-verification
      - risk-manager
      - regulatory-mapper
  
  - id: full-review
    name: å®Œæ•´å¯©æŸ¥çµ„
    description: é«˜é¢¨éšªå™¨æçš„å…¨é¢å¯©æŸ¥
    agents:
      - clinical-evaluator
      - electrical-safety
      - software-verification
      - biocompatibility
      - risk-manager
      - regulatory-mapper
3.3.2 ç·¨æ’å™¨æ ¸å¿ƒå¯¦ä½œ
pythonCopy# core/orchestrator.py
import streamlit as st
import yaml
import asyncio
from typing import List, Dict, Optional
from loguru import logger
import google.generativeai as genai

class AgentOrchestrator:
    """ä»£ç†äººç·¨æ’å™¨"""
    
    def __init__(self, config_path: str = "config/agents.yaml"):
        self.config = self._load_config(config_path)
        self.agents = self._initialize_agents()
        self.execution_queue = []
    
    def _load_config(self, path: str) -> Dict:
        """è¼‰å…¥agents.yamlé…ç½®"""
        try:
            with open(path, 'r', encoding='utf-8') as f:
                return yaml.safe_load(f)
        except Exception as e:
            logger.error(f"é…ç½®æª”æ¡ˆè¼‰å…¥å¤±æ•—: {e}")
            st.error(f"âŒ ç„¡æ³•è¼‰å…¥ä»£ç†äººé…ç½®: {str(e)}")
            return {}
    
    def _initialize_agents(self) -> List[Dict]:
        """åˆå§‹åŒ–ä»£ç†äººåˆ—è¡¨"""
        agents = []
        for agent_def in self.config.get('agents', []):
            if agent_def.get('enabled', True):
                agents.append({
                    **agent_def,
                    'status': 'idle',
                    'output': '',
                    'error': None,
                    'start_time': None,
                    'end_time': None,
                    'token_usage': 0
                })
        return agents
    
    def render_agent_selector(self) -> List[str]:
        """æ¸²æŸ“ä»£ç†äººé¸æ“‡ä»‹é¢"""
        st.subheader("ğŸ¤– é¸æ“‡å¯©æŸ¥ä»£ç†äºº")
        
        # å¿«é€Ÿç¾¤çµ„é¸æ“‡
        groups = self.config.get('agent_groups', [])
        if groups:
            st.write("**å¿«é€Ÿç¾¤çµ„:**")
            group_cols = st.columns(len(groups))
            selected_group = None
            
            for idx, group in enumerate(groups):
                with group_cols[idx]:
                    if st.button(
                        f"{group['name']}\n({len(group['agents'])}å€‹ä»£ç†äºº)",
                        use_container_width=True
                    ):
                        selected_group = group['agents']
        
        st.divider()
        
        # å€‹åˆ¥ä»£ç†äººé¸æ“‡
        st.write("**å€‹åˆ¥é¸æ“‡:**")
        
        # æŒ‰é¡åˆ¥åˆ†çµ„é¡¯ç¤º
        categories = {}
        for agent in self.agents:
            cat = agent.get('category', 'other')
            if cat not in categories:
                categories[cat] = []
            categories[cat].append(agent)
        
        selected_agents = []
        
        category_names = {
            'clinical': 'ğŸ¥ è‡¨åºŠè©•ä¼°',
            'engineering': 'âš¡ å·¥ç¨‹æŠ€è¡“',
            'software': 'ğŸ’» è»Ÿé«”é©—è­‰',
            'biological': 'ğŸ§¬ ç”Ÿç‰©å®‰å…¨',
            'quality': 'âš ï¸ å“è³ªç®¡ç†',
            'regulatory': 'ğŸ“‹ æ³•è¦ç¬¦åˆ'
        }
        
        for cat, agents_in_cat in categories.items():
            with st.expander(category_names.get(cat, cat), expanded=True):
                for agent in agents_in_cat:
                    col1, col2 = st.columns([3, 1])
                    
                    with col1:
                        selected = st.checkbox(
                            f"{agent['icon']} {agent['name']}",
                            value=False,
                            key=f"agent_select_{agent['id']}",
                            help=agent['role']
                        )
                        if selected:
                            selected_agents.append(agent['id'])
                    
                    with col2:
                        # é¡¯ç¤ºå„ªå…ˆç´š
                        st.caption(f"å„ªå…ˆç´š: {agent['priority']}")
        
        # è‹¥é¸æ“‡äº†ç¾¤çµ„,è¦†è“‹å€‹åˆ¥é¸æ“‡
        if selected_group:
            return selected_group
        
        return selected_agents
    
    async def execute_agents(
        self,
        agent_ids: List[str],
        context: str,
        execution_mode: str = 'parallel'
    ):
        """åŸ·è¡Œé¸å®šçš„ä»£ç†äºº"""
        
        # æ§‹å»ºåŸ·è¡Œè¨ˆç•«
        execution_plan = self._build_execution_plan(agent_ids, execution_mode)
        
        # åˆå§‹åŒ–é€²åº¦è¿½è¹¤
        progress_bar = st.progress(0)
        status_text = st.empty()
        
        total_agents = sum(len(batch) for batch in execution_plan)
        completed = 0
        
        # åŸ·è¡Œå„æ‰¹æ¬¡
        for batch_idx, batch in enumerate(execution_plan):
            status_text.text(f"åŸ·è¡Œæ‰¹æ¬¡ {batch_idx + 1}/{len(execution_plan)}")
            
            # å¹³è¡ŒåŸ·è¡ŒåŒæ‰¹æ¬¡çš„ä»£ç†äºº
            tasks = [
                self._execute_single_agent(agent_id, context)
                for agent_id in batch
            ]
            
            results = await asyncio.gather(*tasks, return_exceptions=True)
            
            # æ›´æ–°é€²åº¦
            completed += len(batch)
            progress_bar.progress(completed / total_agents)
        
        status_text.text("âœ… æ‰€æœ‰ä»£ç†äººåŸ·è¡Œå®Œç•¢")
        
        # è¿”å›çµæœ
        return self.agents
    
    def _build_execution_plan(
        self,
        agent_ids: List[str],
        mode: str
    ) -> List[List[str]]:
        """æ§‹å»ºåŸ·è¡Œè¨ˆç•«"""
        
        if mode == 'parallel':
            # å…¨éƒ¨å¹³è¡ŒåŸ·è¡Œ
            return [agent_ids]
        
        elif mode == 'sequential':
            # ä¾å„ªå…ˆç´šé †åºåŸ·è¡Œ
            sorted_agents = sorted(
                [a for a in self.agents if a['id'] in agent_ids],
                key=lambda x: x['priority']
            )
            return [[a['id']] for a in sorted_agents]
        
        elif mode == 'dependency':
            # æ ¹æ“šä¾è³´é—œä¿‚å»ºç«‹æ‰¹æ¬¡
            return self._resolve_dependencies(agent_ids)
        
        else:
            raise ValueError(f"ä¸æ”¯æ´çš„åŸ·è¡Œæ¨¡å¼: {mode}")
    
    def _resolve_dependencies(self, agent_ids: List[str]) -> List[List[str]]:
        """è§£æä¾è³´é—œä¿‚,å»ºç«‹åŸ·è¡Œæ‰¹æ¬¡"""
        from collections import defaultdict, deque
        
        # å»ºç«‹ä¾è³´åœ–
        graph = defaultdict(list)
        in_degree = {aid: 0 for aid in agent_ids}
        
        for agent_id in agent_ids:
            agent = next(a for a in self.agents if a['id'] == agent_id)
            deps = agent.get('dependencies', [])
            
            for dep in deps:
                if dep in agent_ids:
                    graph[dep].append(agent_id)
                    in_degree[agent_id] += 1
        
        # æ‹“æ’²æ’åº
        batches = []
        queue = deque([aid for aid, degree in in_degree.items() if degree == 0])
        
        while queue:
            current_batch = list(queue)
            batches.append(current_batch)
            queue.clear()
            
            for agent_id in current_batch:
                for neighbor in graph[agent_id]:
                    in_degree[neighbor] -= 1
                    if in_degree[neighbor] == 0:
                        queue.append(neighbor)
        
        return batches
    
    async def _execute_single_agent(
        self,
        agent_id: str,
        context: str
    ) -> Dict:
        """åŸ·è¡Œå–®ä¸€ä»£ç†äºº"""
        
        # æ‰¾åˆ°ä»£ç†äººå®šç¾©
        agent = next((a for a in self.agents if a['id'] == agent_id), None)
        if not agent:
            return {'success': False, 'error': 'Agent not found'}
        
        # æ›´æ–°ç‹€æ…‹
        agent['status'] = 'running'
        agent['start_time'] = datetime.now()
        
        # è¨˜éŒ„æ—¥èªŒ
        self._add_log(agent['name'], 'é–‹å§‹åŸ·è¡Œ...', 'info')
        
        try:
            # å‘¼å«Gemini API
            api_key = APIKeyManager().retrieve_api_key()
            genai.configure(api_key=api_key)
            
            model = genai.GenerativeModel(
                model_name='gemini-2.5-flash',
                generation_config=agent.get('generation_config', {}),
                safety_settings=agent.get('safety_settings', [])
            )
            
            # æ§‹å»ºå®Œæ•´æç¤ºè©
            full_prompt = f"{agent['system_prompt']}\n\n=== å¯©æŸ¥æ–‡ä»¶ ===\n{context}"
            
            # ç”Ÿæˆå…§å®¹
            response = await model.generate_content_async(full_prompt)
            
            # æ›´æ–°ä»£ç†äººç‹€æ…‹
            agent['status'] = 'completed'
            agent['output'] = response.text
            agent['token_usage'] = response.usage_metadata.total_token_count
            agent['end_time'] = datetime.now()
            
            self._add_log(agent['name'], 'åŸ·è¡Œå®Œæˆ', 'success')
            
            return {
                'success': True,
                'agent_id': agent_id,
                'output': response.text
            }
            
        except Exception as e:
            agent['status'] = 'failed'
            agent['error'] = str(e)
            agent['end_time'] = datetime.now()
            
            self._add_log(agent['name'], f'åŸ·è¡Œå¤±æ•—: {str(e)}', 'error')
            
            return {
                'success': False,
                'agent_id': agent_id,
                'error': str(e)
            }
    
    def _add_log(self, source: str, message: str, log_type: str):
        """æ·»åŠ æ—¥èªŒè¨˜éŒ„"""
        log_entry = {
            'timestamp': datetime.now(),
            'source': source,
            'message': message,
            'type': log_type
        }
        SessionManager.append('system_logs', log_entry)

7. Streamlitå¯¦ä½œæ¶æ§‹
7.1 å°ˆæ¡ˆçµæ§‹
Copytw-smartreview-2030/
â”œâ”€â”€ app.py                          # ä¸»æ‡‰ç”¨å…¥å£
â”œâ”€â”€ requirements.txt                # Pythonä¾è³´å¥—ä»¶
â”œâ”€â”€ .env                            # ç’°å¢ƒè®Šæ•¸(ä¸ç´å…¥ç‰ˆæ§)
â”œâ”€â”€ .streamlit/
â”‚   â””â”€â”€ config.toml                 # Streamlité…ç½®
â”œâ”€â”€ config/
â”‚   â”œâ”€â”€ agents.yaml                 # ä»£ç†äººå®šç¾©
â”‚   â”œâ”€â”€ painter_styles.yaml         # è¦–è¦ºé¢¨æ ¼å®šç¾©
â”‚   â””â”€â”€ regulatory_standards.yaml   # æ³•è¦æ¨™æº–è³‡æ–™åº«
â”œâ”€â”€ core/
â”‚   â”œâ”€â”€ session_manager.py          # Sessionç‹€æ…‹ç®¡ç†
â”‚   â”œâ”€â”€ orchestrator.py             # ä»£ç†äººç·¨æ’å™¨
â”‚   â””â”€â”€ security.py                 # å®‰å…¨æ€§æ¨¡çµ„
â”œâ”€â”€ services/
â”‚   â”œâ”€â”€ ocr_service.py              # OCRæœå‹™
â”‚   â”œâ”€â”€ gemini_service.py           # Gemini APIå°è£
â”‚   â””â”€â”€ vector_store.py             # å‘é‡è³‡æ–™åº«æœå‹™
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ file_processor.py           # æ–‡ä»¶è™•ç†å…ƒä»¶
â”‚   â”œâ”€â”€ agent_network_viz.py        # ä»£ç†äººç¶²çµ¡è¦–è¦ºåŒ–
â”‚   â”œâ”€â”€ terminal_log.py             # çµ‚ç«¯æ©Ÿæ—¥èªŒå…ƒä»¶
â”‚   â””â”€â”€ note_keeper.py              # æ™ºæ…§ç­†è¨˜å…ƒä»¶
â”œâ”€â”€ pages/
â”‚   â”œâ”€â”€ 1_ğŸ“Š_Dashboard.py           # å„€è¡¨æ¿é é¢
â”‚   â”œâ”€â”€ 2_ğŸ“¤_File_Upload.py         # æ–‡ä»¶ä¸Šå‚³é é¢
â”‚   â”œâ”€â”€ 3_ğŸ¤–_Agent_Execution.py     # ä»£ç†äººåŸ·è¡Œé é¢
â”‚   â”œâ”€â”€ 4_ğŸ“_Review_Results.py      # å¯©æŸ¥çµæœé é¢
â”‚   â”œâ”€â”€ 5_ğŸ¨_Style_Settings.py      # é¢¨æ ¼è¨­å®šé é¢
â”‚   â””â”€â”€ 6_â„¹ï¸_About.py               # é—œæ–¼é é¢
â”œâ”€â”€ utils/
â”‚   â”œâ”€â”€ logger.py                   # æ—¥èªŒå·¥å…·
â”‚   â”œâ”€â”€ validators.py               # è³‡æ–™é©—è­‰
â”‚   â””â”€â”€ helpers.py                  # è¼”åŠ©å‡½å¼
â”œâ”€â”€ assets/
â”‚   â”œâ”€â”€ images/                     # åœ–ç‰‡è³‡æº
â”‚   â”œâ”€â”€ fonts/                      # å­—é«”æª”æ¡ˆ
â”‚   â””â”€â”€ styles/
â”‚       â””â”€â”€ custom.css              # è‡ªå®šç¾©CSS
â””â”€â”€ tests/
    â”œâ”€â”€ test_orchestrator.py        # å–®å…ƒæ¸¬è©¦
    â””â”€â”€ test_ocr_service.py
7.2 ä¸»æ‡‰ç”¨å…¥å£
pythonCopy# app.py
import streamlit as st
from core.session_manager import SessionManager
from core.security import APIKeyManager
from utils.logger import setup_logger
import yaml

# è¨­å®šé é¢é…ç½®
st.set_page_config(
    page_title="TW-SmartReview 2030",
    page_icon="ğŸ¯",
    layout="wide",
    initial_sidebar_state="expanded",
    menu_items={
        'Get Help': 'https://github.com/your-repo',
        'Report a bug': 'https://github.com/your-repo/issues',
        'About': '# TW-SmartReview 2030\næ™ºæ…§åŒ–å¯©æŸ¥ä»£ç†äººç³»çµ±'
    }
)

# åˆå§‹åŒ–æ—¥èªŒ
logger = setup_logger()

# åˆå§‹åŒ–Session State
SessionManager.initialize()

# è¼‰å…¥è‡ªå®šç¾©CSS
def load_custom_css():
    with open('assets/styles/custom.css', 'r', encoding='utf-8') as f:
        st.markdown(f'<style>{f.read()}</style>', unsafe_allow_html=True)

load_custom_css()

# å¥—ç”¨è—è¡“é¢¨æ ¼
def apply_painter_style():
    current_style = SessionManager.get('current_painter_style', 'cyberpunk')
    
    with open('config/painter_styles.yaml', 'r', encoding='utf-8') as f:
        styles = yaml.safe_load(f)
    
    style_config = next(
        (s for s in styles['styles'] if s['id'] == current_style),
        styles['styles'][0]
    )
    
    # æ³¨å…¥å‹•æ…‹æ¨£å¼
    st.markdown(f"""
    <style>
    :root {{
        --bg-gradient: {style_config['bg']};
        --accent-color: {style_config['accent']};
        --font-family: {style_config['font']};
    }}
    
    .stApp {{
        background: var(--bg-gradient);
        font-family: var(--font-family);
    }}
    
    .glass-panel {{
        background: rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 12px;
        padding: 20px;
        box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
    }}
    </style>
    """, unsafe_allow_html=True)

apply_painter_style()

# å´é‚Šæ¬„
with st.sidebar:
    st.image('assets/images/logo.png', width=200)
    st.title("TW-SmartReview 2030")
    st.caption("v4.2.0 | Cinematic Release")
    
    st.divider()
    
    # API Keyè¨­å®š
    st.subheader("ğŸ”‘ APIé‡‘é‘°è¨­å®š")
    
    key_manager = APIKeyManager()
    existing_key = key_manager.retrieve_api_key()
    
    if existing_key:
        st.success("âœ… APIé‡‘é‘°å·²é…ç½®")
        if st.button("æ›´æ–°é‡‘é‘°"):
            SessionManager.set('api_key_configured', False)
            st.rerun()
    else:
        api_key_input = st.text_input(
            "Gemini API Key",
            type="password",
            help="è«‹è¼¸å…¥æ‚¨çš„Google Gemini APIé‡‘é‘°"
        )
        
        if st.button("å„²å­˜é‡‘é‘°"):
            if key_manager.validate_key(api_key_input):
                key_manager.store_api_key(api_key_input)
                st.success("âœ… é‡‘é‘°å·²å„²å­˜")
                st.rerun()
            else:
                st.error("âŒ é‡‘é‘°ç„¡æ•ˆ,è«‹æª¢æŸ¥å¾Œé‡è©¦")
    
    st.divider()
    
    # æ¨¡å‹é¸æ“‡
    st.subheader("ğŸ¤– æ¨¡å‹è¨­å®š")
    model_choice = st.selectbox(
        "é¸æ“‡AIæ¨¡å‹",
        options=[
            "gemini-2.5-flash",
            "gemini-2.5-flash-lite"
        ],
        index=0
    )
    SessionManager.set('selected_model', model_choice)
    
    st.divider()
    
    # ç³»çµ±ç‹€æ…‹
    st.subheader("ğŸ“Š ç³»çµ±ç‹€æ…‹")
    status = SessionManager.get('workflow_status', 'idle')
    status_emoji = {
        'idle': 'ğŸŸ¢',
        'processing': 'ğŸ”µ',
        'completed': 'ğŸŸ¢',
        'error': 'ğŸ”´'
    }
    st.info(f"{status_emoji[status]} {status.upper()}")
    
    # æ´»èºä»£ç†äººæ•¸
    active_agents = SessionManager.get('active_agents', [])
    running_agents = [a for a in active_agents if a['status'] == 'running']
    st.metric("æ´»èºä»£ç†äºº", len(running_agents))
    
    st.divider()
    
    # å¿«é€Ÿé€£çµ
    st.subheader("ğŸ”— å¿«é€Ÿé€£çµ")
    st.page_link("pages/1_ğŸ“Š_Dashboard.py", label="å„€è¡¨æ¿")
    st.page_link("pages/2_ğŸ“¤_File_Upload.py", label="æ–‡ä»¶ä¸Šå‚³")
    st.page_link("pages/3_ğŸ¤–_Agent_Execution.py", label="ä»£ç†äººåŸ·è¡Œ")
    st.page_link("pages/4_ğŸ“_Review_Results.py", label="å¯©æŸ¥çµæœ")

# ä¸»é é¢å…§å®¹
st.title("ğŸ¯ æ­¡è¿ä½¿ç”¨ TW-SmartReview 2030")

col1, col2 = st.columns(2)

with col1:
    st.markdown("""
    ### ğŸš€ ç³»çµ±ç‰¹è‰²
    
    - **æ™ºæ…§åŒ–**: é‹ç”¨æœ€å…ˆé€²çš„AIæ¨¡å‹é€²è¡Œæ–‡ä»¶ç†è§£èˆ‡åˆ†æ
    - **è‡ªå‹•åŒ–**: æ‰¹æ¬¡è™•ç†å¤šä»½æ–‡ä»¶,å¤§å¹…æå‡å¯©æŸ¥æ•ˆç‡
    - **é€æ˜åŒ–**: æ‰€æœ‰æ¨ç†éç¨‹å¯è¿½æº¯,ç¬¦åˆç›£ç®¡è¦æ±‚
    - **å”åŒåŒ–**: å¤šä»£ç†äººå”ä½œ,æ¨¡æ“¬è·¨éƒ¨é–€å¯©æŸ¥åœ˜éšŠ
    - **éš±ç§å„ªå…ˆ**: ç„¡å¾Œç«¯æ¶æ§‹,è³‡æ–™ä¸é›¢é–‹æœ¬åœ°ç«¯
    """)

with col2:
    st.markdown("""
    ### ğŸ“‹ å¿«é€Ÿé–‹å§‹
    
    1. **è¨­å®šAPIé‡‘é‘°**: åœ¨å´é‚Šæ¬„è¼¸å…¥æ‚¨çš„Gemini API Key
    2. **ä¸Šå‚³æ–‡ä»¶**: å‰å¾€ã€Œæ–‡ä»¶ä¸Šå‚³ã€é é¢
    3. **é¸æ“‡ä»£ç†äºº**: åœ¨ã€Œä»£ç†äººåŸ·è¡Œã€é é¢é¸æ“‡å¯©æŸ¥é …ç›®
    4. **æŸ¥çœ‹çµæœ**: åœ¨ã€Œå¯©æŸ¥çµæœã€é é¢æª¢è¦–å ±å‘Š
    """)

st.divider()

# ç³»çµ±æ¶æ§‹åœ–
st.subheader("ğŸ—ï¸ ç³»çµ±æ¶æ§‹")

with st.expander("æŸ¥çœ‹æ¶æ§‹åœ–", expanded=False):
    st.image('assets/images/architecture_diagram.png', use_column_width=True)

# æœ€æ–°å‹•æ…‹
st.subheader("ğŸ“¢ æœ€æ–°å‹•æ…‹")

news_items = [
    {"date": "2025-12-15", "title": "v4.2.0 Cinematic Releaseç™¼å¸ƒ", "type": "release"},
    {"date": "2025-12-10", "title": "æ–°å¢å€å¡Šéˆç¨½æ ¸è»Œè·¡åŠŸèƒ½", "type": "feature"},
    {"date": "2025-12-05", "title": "æ”¯æ´å¤šåœ‹æ³•è¦å”èª¿æ¨¡çµ„", "type": "feature"},
]

for item in news_items:
    badge_color = "blue" if item['type'] == 'release' else "green"
    st.markdown(f"""
    <div class="glass-panel" style="margin-bottom: 10px;">
        <span style="color: gray;">{item['date']}</span>
        <span style="background: {badge_color}; color: white; padding: 2px 8px; border-radius: 4px; margin-left: 10px;">{item['type'].upper()}</span>
        <br>
        <strong>{item['title']}</strong>
    </div>
    """, unsafe_allow_html=True)

# Footer
st.divider()
st.caption("Â© 2025 TW-SmartReview 2030 Project | Powered by Google Gemini AI")
7.3 è‡ªå®šç¾©CSSæ¨£å¼
cssCopy/* assets/styles/custom.css */

/* ç»ç’ƒæ“¬æ…‹é¢æ¿ */
.glass-panel {
    background: rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 12px;
    padding: 20px;
    box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
    transition: all 0.3s ease;
}

.glass-panel:hover {
    transform: translateY(-2px);
    box-shadow: 0 12px 40px 0 rgba(0, 0, 0, 0.45);
}

/* çµ‚ç«¯æ©Ÿæ—¥èªŒæ¨£å¼ */
.terminal-log {
    background: #1e1e1e;
    color: #00ff00;
    font-family: 'Courier New', monospace;
    padding: 15px;
    border-radius: 8px;
    height: 400px;
    overflow-y: auto;
    font-size: 13px;
    line-height: 1.5;
}

.log-entry {
    margin-bottom: 5px;
}

.log-timestamp {
    color: #888;
}

.log-source {
    color: #00bfff;
    font-weight: bold;
}

.log-info {
    color: #00ff00;
}

.log-success {
    color: #32cd32;
}

.log-warning {
    color: #ffa500;
}

.log-error {
    color: #ff4500;
}

.log-system {
    color: #1e90ff;
}

/* ç‹€æ…‹æŒ‡ç¤ºå™¨å‹•ç•« */
@keyframes pulse {
    0%, 100% {
        opacity: 1;
    }
    50% {
        opacity: 0.5;
    }
}

.status-indicator {
    width: 12px;
    height: 12px;
    border-radius: 50%;
    display: inline-block;
    animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
}

.status-operational {
    background-color: #10b981;
}
status-processing {
    background-color: #3b82f6;
}

.status-error {
    background-color: #ef4444;
}

/* ä»£ç†äººå¡ç‰‡æ¨£å¼ */
.agent-card {
    background: linear-gradient(135deg, rgba(139, 92, 246, 0.1) 0%, rgba(59, 130, 246, 0.1) 100%);
    border: 2px solid rgba(139, 92, 246, 0.3);
    border-radius: 12px;
    padding: 20px;
    margin: 10px 0;
    transition: all 0.3s ease;
    position: relative;
    overflow: hidden;
}

.agent-card::before {
    content: '';
    position: absolute;
    top: -50%;
    left: -50%;
    width: 200%;
    height: 200%;
    background: radial-gradient(circle, rgba(139, 92, 246, 0.1) 0%, transparent 70%);
    animation: rotate 10s linear infinite;
}

@keyframes rotate {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
}

.agent-card:hover {
    transform: translateY(-5px);
    box-shadow: 0 10px 30px rgba(139, 92, 246, 0.3);
    border-color: rgba(139, 92, 246, 0.6);
}

/* æŒ‰éˆ•æ¨£å¼å¢å¼· */
.stButton > button {
    border-radius: 8px;
    font-weight: 600;
    transition: all 0.2s ease;
    border: none;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
}

.stButton > button:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
}

/* é€²åº¦æ¢æ¨£å¼ */
.stProgress > div > div {
    background: linear-gradient(90deg, #8b5cf6 0%, #3b82f6 100%);
    border-radius: 10px;
    height: 8px;
}

/* æ¨™ç±¤é æ¨£å¼ */
.stTabs [data-baseweb="tab-list"] {
    gap: 8px;
}

.stTabs [data-baseweb="tab"] {
    border-radius: 8px 8px 0 0;
    padding: 12px 24px;
    background-color: rgba(255, 255, 255, 0.05);
}

.stTabs [aria-selected="true"] {
    background-color: rgba(139, 92, 246, 0.2);
    border-bottom: 3px solid #8b5cf6;
}

/* Markdownå…§å®¹ç¾åŒ– */
.markdown-content {
    line-height: 1.8;
    color: #e5e7eb;
}

.markdown-content h1 {
    color: #8b5cf6;
    border-bottom: 2px solid #8b5cf6;
    padding-bottom: 10px;
    margin-top: 30px;
}

.markdown-content h2 {
    color: #3b82f6;
    margin-top: 25px;
}

.markdown-content code {
    background-color: rgba(139, 92, 246, 0.1);
    padding: 2px 6px;
    border-radius: 4px;
    color: #a78bfa;
}

/* è¡¨æ ¼æ¨£å¼ */
.dataframe {
    border: none !important;
    border-radius: 8px;
    overflow: hidden;
}

.dataframe thead tr {
    background: linear-gradient(90deg, #8b5cf6 0%, #3b82f6 100%);
    color: white;
}

.dataframe tbody tr:hover {
    background-color: rgba(139, 92, 246, 0.1);
}

8. agents.yamlé…ç½®ç³»çµ±
8.1 é…ç½®æª”æ¡ˆæ¶æ§‹è¨­è¨ˆ
agents.yamlæ˜¯æ•´å€‹ç³»çµ±çš„ã€Œå¤§è…¦é…ç½®æª”æ¡ˆã€,å®šç¾©äº†æ‰€æœ‰AIä»£ç†äººçš„è¡Œç‚ºã€èƒ½åŠ›èˆ‡å”ä½œé—œä¿‚ã€‚æœ¬ç³»çµ±æ¡ç”¨è²æ˜å¼é…ç½®(Declarative Configuration)æ¨¡å¼,ä½¿å¾—éæŠ€è¡“äººå“¡ä¹Ÿèƒ½é€éç·¨è¼¯YAMLæª”æ¡ˆä¾†è‡ªå®šç¾©å¯©æŸ¥æµç¨‹ã€‚
8.1.1 é…ç½®æª”æ¡ˆçš„æ ¸å¿ƒå„ªå‹¢

å¯è®€æ€§é«˜: YAMLçš„ç¸®æ’å¼èªæ³•ç›´è§€æ˜“æ‡‚
ç‰ˆæœ¬æ§åˆ¶å‹å–„: ç´”æ–‡å­—æ ¼å¼ä¾¿æ–¼Gitè¿½è¹¤è®Šæ›´
ç†±æ›´æ–°æ”¯æ´: ä¿®æ”¹é…ç½®å¾Œç„¡éœ€é‡æ–°éƒ¨ç½²æ‡‰ç”¨
å¤šç’°å¢ƒé…ç½®: å¯é‡å°é–‹ç™¼/æ¸¬è©¦/ç”Ÿç”¢ç’°å¢ƒä½¿ç”¨ä¸åŒé…ç½®
Schemaé©—è­‰: å¯é€éJSON Schemaé©—è­‰é…ç½®æ­£ç¢ºæ€§

8.1.2 é€²éšé…ç½®ç¯„ä¾‹
yamlCopy# config/agents.yaml (é€²éšç‰ˆ)

meta:
  version: "4.2.0"
  last_updated: "2025-12-15"
  schema_version: "2.0"
  author: "TW-SmartReview Development Team"
  
# å…¨åŸŸè¨­å®š
global_settings:
  default_model: "gemini-2.5-flash"
  max_concurrent_agents: 5
  timeout_seconds: 300
  retry_policy:
    max_retries: 3
    backoff_factor: 2
  
  generation_config:
    temperature: 0.3
    top_p: 0.9
    top_k: 40
    max_output_tokens: 4096
  
  safety_settings:
    - category: HARM_CATEGORY_HARASSMENT
      threshold: BLOCK_MEDIUM_AND_ABOVE
    - category: HARM_CATEGORY_HATE_SPEECH
      threshold: BLOCK_MEDIUM_AND_ABOVE
    - category: HARM_CATEGORY_SEXUALLY_EXPLICIT
      threshold: BLOCK_MEDIUM_AND_ABOVE
    - category: HARM_CATEGORY_DANGEROUS_CONTENT
      threshold: BLOCK_MEDIUM_AND_ABOVE

# ä»£ç†äººå®šç¾©
agents:
  - id: labeling-reviewer
    name: æ¨™ç±¤èˆ‡èªªæ˜æ›¸å¯©æŸ¥åŠ©æ‰‹
    name_en: Labeling & IFU Review Assistant
    role: å¯©æŸ¥ç”¢å“æ¨™ç±¤èˆ‡ä½¿ç”¨èªªæ˜æ›¸çš„åˆè¦æ€§
    category: regulatory
    icon: "ğŸ·ï¸"
    priority: 7
    enabled: true
    dependencies: []
    
    # è‡ªå®šç¾©é…ç½®(è¦†è“‹å…¨åŸŸè¨­å®š)
    generation_config:
      temperature: 0.2  # æ¨™ç±¤å¯©æŸ¥éœ€è¦æ›´åš´æ ¼çš„è¼¸å‡º
      max_output_tokens: 3072
    
    system_prompt: |
      ä½ æ˜¯ä¸€ä½é†«ç™‚å™¨ææ¨™ç±¤èˆ‡èªªæ˜æ›¸å¯©æŸ¥å°ˆå®¶,ç†Ÿæ‚‰FDA 21 CFR Part 801èˆ‡EU MDR Annex Iè¦æ±‚ã€‚
      
      ã€å¯©æŸ¥ç¯„åœã€‘
      1. **å¤–ç›’æ¨™ç±¤(Outer Label)**
         - è£½é€ å•†è³‡è¨Šå®Œæ•´æ€§
         - å™¨æåç¨±èˆ‡å‹è™Ÿ
         - æ‰¹è™Ÿ/åºè™Ÿ/å¤±æ•ˆæ—¥æœŸ
         - å„²å­˜æ¢ä»¶æ¨™ç¤º
         - è­¦èªèˆ‡æ³¨æ„äº‹é …
      
      2. **ä½¿ç”¨èªªæ˜æ›¸(Instructions for Use, IFU)**
         - é©æ‡‰ç—‡/ç¦å¿Œç—‡æè¿°
         - æ“ä½œæ­¥é©Ÿæ¸…æ™°åº¦
         - è­¦å‘Šèˆ‡é é˜²æªæ–½
         - ä¸è‰¯åæ‡‰èªªæ˜
         - æŠ€è¡“è¦æ ¼è¡¨
         - åœ–ç¤ºç¬¦è™Ÿç¬¦åˆISO 15223-1
      
      3. **å¤šèªè¨€ä¸€è‡´æ€§**
         - æª¢æŸ¥ä¸­è‹±æ–‡ç‰ˆæœ¬è³‡è¨Šæ˜¯å¦ä¸€è‡´
         - å°ˆæ¥­è¡“èªç¿»è­¯æ­£ç¢ºæ€§
      
      ã€é‡é»æª¢æŸ¥é …ç›®ã€‘
      - æ˜¯å¦åŒ…å«FDAè¦æ±‚çš„Rx/OTCæ¨™ç¤º
      - å–®æ¬¡ä½¿ç”¨å™¨ææ˜¯å¦æ¨™ç¤º"SINGLE USE"
      - æ»…èŒå™¨ææ˜¯å¦æ¨™ç¤ºæ»…èŒæ–¹æ³•
      - CEæ¨™èªŒèˆ‡å…¬å‘Šæ©Ÿæ§‹ç·¨è™Ÿ(è‹¥é©ç”¨)
      - UDIæ¢ç¢¼è³‡è¨Šå®Œæ•´æ€§
      
      ã€è¼¸å‡ºæ ¼å¼ã€‘
      # æ¨™ç±¤èˆ‡èªªæ˜æ›¸å¯©æŸ¥å ±å‘Š
      
      ## å¤–ç›’æ¨™ç±¤æª¢æŸ¥
      | é …ç›® | è¦æ±‚ | ç¾ç‹€ | ç¬¦åˆæ€§ |
      |------|------|------|--------|
      | è£½é€ å•†åç¨± | å¿…é ˆ | [æœ‰/ç„¡] | [âœ“/âœ—] |
      | æ‰¹è™Ÿ | å¿…é ˆ | [æœ‰/ç„¡] | [âœ“/âœ—] |
      
      ## ä½¿ç”¨èªªæ˜æ›¸æª¢æŸ¥
      ### é©æ‡‰ç—‡æè¿°
      [è©•ä¼°å…§å®¹]
      
      ### æ“ä½œæ­¥é©Ÿ
      [è©•ä¼°å…§å®¹]
      
      ### è­¦å‘Šäº‹é …
      [è©•ä¼°å…§å®¹]
      
      ## å¤šèªè¨€ä¸€è‡´æ€§æª¢æŸ¥
      [ç™¼ç¾çš„å·®ç•°]
      
      ## åœ–ç¤ºç¬¦è™Ÿæª¢æŸ¥
      | ç¬¦è™Ÿ | ISOæ¨™æº– | ç¬¦åˆæ€§ |
      |------|---------|--------|
      
      ## æ•´é«”ç¬¦åˆæ€§è©•ä¼°
      - FDA 21 CFR 801: [PASS/FAIL]
      - EU MDR Annex I: [PASS/FAIL]
      
      ## æ”¹å–„å»ºè­°
      1. [å»ºè­°1]
      2. [å»ºè­°2]
    
    # å¾Œè™•ç†å‡½å¼(å¯é¸)
    post_processing:
      - type: extract_checklist
        config:
          format: json
      - type: highlight_gaps
        config:
          severity: major

  - id: post-market-surveillance
    name: ä¸Šå¸‚å¾Œç›£æ¸¬æ•´åˆåˆ†æå¸«
    name_en: Post-Market Surveillance Analyst
    role: åˆ†æä¸Šå¸‚å¾Œç›£æ¸¬æ•¸æ“šèˆ‡ä¸è‰¯äº‹ä»¶å ±å‘Š
    category: quality
    icon: "ğŸ“¡"
    priority: 8
    enabled: true
    dependencies:
      - risk-manager
    
    system_prompt: |
      ä½ æ˜¯ä¸€ä½ä¸Šå¸‚å¾Œç›£æ¸¬(PMS)å°ˆå®¶,å°ˆç²¾æ–¼é†«ç™‚å™¨æè­¦æˆ’(Medical Device Vigilance)ã€‚
      
      ã€è³‡æ–™ä¾†æºã€‘
      - FDA MAUDEè³‡æ–™åº«ä¸è‰¯äº‹ä»¶å ±å‘Š
      - å®¢è¨´è¨˜éŒ„(Customer Complaints)
      - ç¾å ´ç³¾æ­£æªæ–½å ±å‘Š(Field Corrective Actions)
      - è‡¨åºŠæ–‡ç»ä¸­çš„ä¸è‰¯åæ‡‰å ±å‘Š
      
      ã€åˆ†æä»»å‹™ã€‘
      1. **è¶¨å‹¢åˆ†æ**: è­˜åˆ¥ä¸è‰¯äº‹ä»¶ç™¼ç”Ÿç‡çš„æ™‚é–“è¶¨å‹¢
      2. **æ ¹å› åˆ†æ**: æ­¸ç´ä¸è‰¯äº‹ä»¶çš„ä¸»è¦æˆå› é¡åˆ¥
      3. **åš´é‡æ€§è©•ä¼°**: ä¾ISO 14971è©•ä¼°é¢¨éšªç­‰ç´š
      4. **CAPAè¿½è¹¤**: æª¢æŸ¥çŸ¯æ­£èˆ‡é é˜²æªæ–½çš„æœ‰æ•ˆæ€§
      5. **å¬å›è©•ä¼°**: åˆ¤æ–·æ˜¯å¦éœ€å•Ÿå‹•ç”¢å“å¬å›ç¨‹åº
      
      ã€è¼¸å‡ºæ ¼å¼ã€‘
      # ä¸Šå¸‚å¾Œç›£æ¸¬åˆ†æå ±å‘Š
      
      ## è³‡æ–™æ¦‚è¦½
      - åˆ†ææœŸé–“: [èµ·è¨–æ—¥æœŸ]
      - ä¸è‰¯äº‹ä»¶ç¸½æ•¸: [æ•¸é‡]
      - åš´é‡ä¸è‰¯äº‹ä»¶: [æ•¸é‡]
      
      ## äº‹ä»¶é¡åˆ¥åˆ†å¸ƒ
      | é¡åˆ¥ | æ•¸é‡ | ç™¾åˆ†æ¯” |
      |------|------|--------|
      | è¨­å‚™æ•…éšœ | X | XX% |
      | ä½¿ç”¨è€…éŒ¯èª¤ | X | XX% |
      
      ## è¶¨å‹¢åœ–åˆ†æ
      [æè¿°ç™¼ç”Ÿç‡è®ŠåŒ–è¶¨å‹¢]
      
      ## æ ¹å› åˆ†æ
      ### Top 5 æ ¹æœ¬åŸå› 
      1. [åŸå› 1] - ç™¼ç”Ÿæ¬¡æ•¸: X
      
      ## é¢¨éšªä¿¡è™Ÿåµæ¸¬
      [æ˜¯å¦å‡ºç¾æ–°çš„å®‰å…¨æ€§ä¿¡è™Ÿ]
      
      ## CAPAæœ‰æ•ˆæ€§è©•ä¼°
      [å·²å¯¦æ–½æªæ–½çš„æ•ˆæœè¿½è¹¤]
      
      ## å»ºè­°æªæ–½
      - [ ] æ›´æ–°é¢¨éšªç®¡ç†æª”æ¡ˆ
      - [ ] ä¿®è¨‚ä½¿ç”¨èªªæ˜æ›¸
      - [ ] å•Ÿå‹•ä¸»å‹•å¬å›
      - [ ] é€šå ±ä¸»ç®¡æ©Ÿé—œ

  - id: ai-ml-validator
    name: AI/MLæ¼”ç®—æ³•é©—è­‰å°ˆå®¶
    name_en: AI/ML Algorithm Validator
    role: é©—è­‰AI/MLé†«ç™‚å™¨æçš„æ¼”ç®—æ³•æ€§èƒ½
    category: software
    icon: "ğŸ§ "
    priority: 9
    enabled: true
    dependencies:
      - software-verification
    
    system_prompt: |
      ä½ æ˜¯ä¸€ä½AI/MLé†«ç™‚å™¨æé©—è­‰å°ˆå®¶,ç†Ÿæ‚‰FDA AI/ML Guidanceèˆ‡EU MDCG 2019-11ã€‚
      
      ã€é©—è­‰é‡é»ã€‘
      1. **è¨“ç·´è³‡æ–™å“è³ª**
         - è³‡æ–™é›†å¤§å°èˆ‡å¤šæ¨£æ€§
         - æ¨™è¨»å“è³ª(Inter-annotator agreement)
         - è³‡æ–™åå·®(Bias)æª¢æ¸¬
         - è³‡æ–™ä¾†æºçš„ä»£è¡¨æ€§
      
      2. **æ¨¡å‹æ€§èƒ½æŒ‡æ¨™**
         - éˆæ•åº¦(Sensitivity/Recall)
         - ç‰¹ç•°æ€§(Specificity)
         - ç²¾ç¢ºåº¦(Precision)
         - AUC-ROCæ›²ç·š
         - F1 Score
         - æ··æ·†çŸ©é™£(Confusion Matrix)
      
      3. **æ¨¡å‹ç©©å¥æ€§**
         - å°æŠ—æ€§æ”»æ“Šæ¸¬è©¦
         - é‚Šç•Œæ¡ˆä¾‹(Edge Cases)è™•ç†
         - è·¨äººç¾¤æ³›åŒ–èƒ½åŠ›
         - é™ç´šæ€§èƒ½(Graceful Degradation)
      
      4. **å¯è§£é‡‹æ€§**
         - ç‰¹å¾µé‡è¦æ€§åˆ†æ
         - æ³¨æ„åŠ›æ©Ÿåˆ¶è¦–è¦ºåŒ–
         - åäº‹å¯¦è§£é‡‹(Counterfactual Explanations)
      
      5. **æŒçºŒå­¸ç¿’æ©Ÿåˆ¶**
         - æ¨¡å‹æ›´æ–°ç­–ç•¥
         - æ€§èƒ½ç›£æ§æ©Ÿåˆ¶
         - å†è¨“ç·´è§¸ç™¼æ¢ä»¶
      
      ã€è¼¸å‡ºæ ¼å¼ã€‘
      # AI/MLæ¼”ç®—æ³•é©—è­‰å ±å‘Š
      
      ## æ¨¡å‹åŸºæœ¬è³‡è¨Š
      - æ¨¡å‹æ¶æ§‹: [CNN/Transformer/ç­‰]
      - è¨“ç·´è³‡æ–™é›†: [åç¨±èˆ‡è¦æ¨¡]
      - é©—è­‰è³‡æ–™é›†: [åç¨±èˆ‡è¦æ¨¡]
      
      ## æ€§èƒ½æŒ‡æ¨™
      | æŒ‡æ¨™ | è¨“ç·´é›† | é©—è­‰é›† | æ¸¬è©¦é›† | FDAè¦æ±‚ |
      |------|--------|--------|--------|---------|
      | éˆæ•åº¦ | XX% | XX% | XX% | >85% |
      | ç‰¹ç•°æ€§ | XX% | XX% | XX% | >90% |
      
      ## å­ç¾¤åˆ†æ
      [ä¸åŒäººå£çµ±è¨ˆå­¸ç‰¹å¾µä¸‹çš„æ€§èƒ½å·®ç•°]
      
      ## å¤±æ•—æ¡ˆä¾‹åˆ†æ
      [æ¨¡å‹é æ¸¬éŒ¯èª¤çš„æ¡ˆä¾‹æ¨¡å¼]
      
      ## å¯è§£é‡‹æ€§è©•ä¼°
      [æ¨¡å‹æ±ºç­–çš„å¯ç†è§£æ€§]
      
      ## æŒçºŒå­¸ç¿’æ©Ÿåˆ¶å¯©æŸ¥
      [æ¨¡å‹æ›´æ–°çš„é¢¨éšªæ§åˆ¶]
      
      ## ç¬¦åˆæ€§çµè«–
      - FDA AI/ML Guidance: [PASS/FAIL]
      - EU MDCG 2019-11: [PASS/FAIL]

# ä»£ç†äººç¾¤çµ„å®šç¾©(æ“´å±•ç‰ˆ)
agent_groups:
  - id: ai-device-review
    name: AI/MLå™¨æå°ˆç”¨å¯©æŸ¥çµ„
    description: é‡å°è»Ÿé«”å³é†«ç™‚å™¨æ(SaMD)çš„å°ˆé …å¯©æŸ¥
    agents:
      - software-verification
      - ai-ml-validator
      - risk-manager
      - post-market-surveillance
    
  - id: implant-review
    name: æ¤å…¥å¼å™¨æå¯©æŸ¥çµ„
    description: é«˜é¢¨éšªæ¤å…¥å¼å™¨æçš„å…¨é¢å¯©æŸ¥
    agents:
      - clinical-evaluator
      - biocompatibility
      - electrical-safety
      - labeling-reviewer
      - risk-manager
    
  - id: ivd-review
    name: é«”å¤–è¨ºæ–·å™¨æå¯©æŸ¥çµ„
    description: IVDå™¨æçš„ç‰¹å®šå¯©æŸ¥é …ç›®
    agents:
      - clinical-evaluator
      - analytical-performance-evaluator  # éœ€é¡å¤–å®šç¾©
      - labeling-reviewer
      - risk-manager

# å·¥ä½œæµç¨‹å®šç¾©
workflows:
  - id: standard-510k
    name: æ¨™æº–510(k)å¯©æŸ¥æµç¨‹
    description: FDA 510(k)ä¸Šå¸‚å‰é€šå ±å¯©æŸ¥
    trigger: manual
    steps:
      - stage: preliminary
        agents:
          - regulatory-mapper
        execution: sequential
        
      - stage: technical-review
        agents:
          - clinical-evaluator
          - electrical-safety
          - software-verification
          - biocompatibility
        execution: parallel
        
      - stage: risk-assessment
        agents:
          - risk-manager
        execution: sequential
        dependencies:
          - technical-review
        
      - stage: labeling-review
        agents:
          - labeling-reviewer
        execution: sequential
        
      - stage: final-report
        agents:
          - report-generator  # éœ€é¡å¤–å®šç¾©
        execution: sequential
        dependencies:
          - risk-assessment
          - labeling-review

# é€šçŸ¥è¨­å®š
notifications:
  - event: agent_completed
    channels:
      - email
      - webhook
    template: "ä»£ç†äºº {{agent_name}} å·²å®Œæˆå¯©æŸ¥"
  
  - event: high_risk_detected
    channels:
      - email
      - sms
    template: "åµæ¸¬åˆ°é«˜é¢¨éšªé …ç›®,è«‹ç«‹å³æª¢è¦–"

# å¯©è¨ˆè¨­å®š
audit:
  enabled: true
  log_level: detailed
  retention_days: 2555  # 7å¹´(ä¾FDAè¦æ±‚)
  blockchain_enabled: true
  blockchain_network: "hyperledger-fabric"
8.2 é…ç½®è¼‰å…¥èˆ‡é©—è­‰
pythonCopy# core/config_manager.py
import yaml
from typing import Dict, List, Optional
from pydantic import BaseModel, Field, validator
import streamlit as st

class AgentConfig(BaseModel):
    """ä»£ç†äººé…ç½®è³‡æ–™æ¨¡å‹"""
    id: str = Field(..., min_length=1)
    name: str
    name_en: Optional[str]
    role: str
    category: str
    icon: str = "ğŸ¤–"
    priority: int = Field(default=5, ge=1, le=10)
    enabled: bool = True
    dependencies: List[str] = []
    system_prompt: str
    generation_config: Optional[Dict] = None
    safety_settings: Optional[List[Dict]] = None
    post_processing: Optional[List[Dict]] = None
    
    @validator('dependencies')
    def validate_dependencies(cls, v, values):
        """é©—è­‰ä¾è³´é—œä¿‚ä¸èƒ½å½¢æˆå¾ªç’°"""
        if values.get('id') in v:
            raise ValueError("ä»£ç†äººä¸èƒ½ä¾è³´è‡ªå·±")
        return v

class WorkflowConfig(BaseModel):
    """å·¥ä½œæµç¨‹é…ç½®"""
    id: str
    name: str
    description: str
    trigger: str = "manual"
    steps: List[Dict]

class ConfigManager:
    """é…ç½®ç®¡ç†å™¨"""
    
    def __init__(self, config_path: str = "config/agents.yaml"):
        self.config_path = config_path
        self.raw_config = None
        self.agents = []
        self.workflows = []
        self.load_config()
    
    def load_config(self):
        """è¼‰å…¥ä¸¦é©—è­‰é…ç½®æª”æ¡ˆ"""
        try:
            with open(self.config_path, 'r', encoding='utf-8') as f:
                self.raw_config = yaml.safe_load(f)
            
            # é©—è­‰schemaç‰ˆæœ¬
            schema_version = self.raw_config.get('meta', {}).get('schema_version', '1.0')
            if schema_version != '2.0':
                st.warning(f"é…ç½®æª”æ¡ˆç‰ˆæœ¬({schema_version})å¯èƒ½ä¸ç›¸å®¹")
            
            # è§£æä»£ç†äººé…ç½®
            for agent_def in self.raw_config.get('agents', []):
                try:
                    agent = AgentConfig(**agent_def)
                    self.agents.append(agent)
                except Exception as e:
                    st.error(f"ä»£ç†äººé…ç½®éŒ¯èª¤ [{agent_def.get('id')}]: {str(e)}")
            
            # è§£æå·¥ä½œæµç¨‹é…ç½®
            for workflow_def in self.raw_config.get('workflows', []):
                workflow = WorkflowConfig(**workflow_def)
                self.workflows.append(workflow)
            
            # é©—è­‰ä¾è³´é—œä¿‚å®Œæ•´æ€§
            self.validate_dependencies()
            
            st.success(f"âœ… æˆåŠŸè¼‰å…¥ {len(self.agents)} å€‹ä»£ç†äºº, {len(self.workflows)} å€‹å·¥ä½œæµç¨‹")
            
        except FileNotFoundError:
            st.error(f"âŒ æ‰¾ä¸åˆ°é…ç½®æª”æ¡ˆ: {self.config_path}")
        except yaml.YAMLError as e:
            st.error(f"âŒ YAMLè§£æéŒ¯èª¤: {str(e)}")
    
    def validate_dependencies(self):
        """é©—è­‰æ‰€æœ‰ä¾è³´çš„ä»£ç†äººéƒ½å­˜åœ¨"""
        agent_ids = {agent.id for agent in self.agents}
        
        for agent in self.agents:
            for dep in agent.dependencies:
                if dep not in agent_ids:
                    st.warning(f"âš ï¸ ä»£ç†äºº [{agent.name}] ä¾è³´çš„ [{dep}] ä¸å­˜åœ¨")
    
    def get_agent_by_id(self, agent_id: str) -> Optional[AgentConfig]:
        """æ ¹æ“šIDå–å¾—ä»£ç†äººé…ç½®"""
        return next((a for a in self.agents if a.id == agent_id), None)
    
    def get_agents_by_category(self, category: str) -> List[AgentConfig]:
        """æ ¹æ“šé¡åˆ¥å–å¾—ä»£ç†äººåˆ—è¡¨"""
        return [a for a in self.agents if a.category == category]
    
    def get_workflow_by_id(self, workflow_id: str) -> Optional[WorkflowConfig]:
        """æ ¹æ“šIDå–å¾—å·¥ä½œæµç¨‹é…ç½®"""
        return next((w for w in self.workflows if w.id == workflow_id), None)
    
    def export_config(self, output_path: str):
        """åŒ¯å‡ºé…ç½®ç‚ºYAMLæª”æ¡ˆ"""
        with open(output_path, 'w', encoding='utf-8') as f:
            yaml.dump(self.raw_config, f, allow_unicode=True, default_flow_style=False)

9. FDAå°ˆç”¨é€²éšåŠŸèƒ½æ¨¡çµ„
9.1 æ³•è¦æ™ºæ…§æ¯”å°å¼•æ“
æ­¤æ¨¡çµ„åˆ©ç”¨å‘é‡è³‡æ–™åº«æŠ€è¡“,å¯¦ç¾é€å¯©æ–‡ä»¶èˆ‡æ³•è¦æ¢æ–‡çš„èªç¾©ç›¸ä¼¼åº¦æ¯”å°ã€‚
pythonCopy# services/regulatory_matcher.py
import streamlit as st
from pinecone import Pinecone, ServerlessSpec
from sentence_transformers import SentenceTransformer
import google.generativeai as genai
from typing import List, Dict

class RegulatoryMatcher:
    """æ³•è¦æ™ºæ…§æ¯”å°å¼•æ“"""
    
    def __init__(self):
        # åˆå§‹åŒ–Pineconeå‘é‡è³‡æ–™åº«
        self.pc = Pinecone(api_key=st.secrets.get("PINECONE_API_KEY"))
        self.index_name = "regulatory-standards"
        
        # åˆå§‹åŒ–åµŒå…¥æ¨¡å‹
        self.embedder = SentenceTransformer('paraphrase-multilingual-mpnet-base-v2')
        
        # å»ºç«‹æˆ–é€£æ¥ç´¢å¼•
        if self.index_name not in self.pc.list_indexes().names():
            self.pc.create_index(
                name=self.index_name,
                dimension=768,  # æ¨¡å‹è¼¸å‡ºç¶­åº¦
                metric='cosine',
                spec=ServerlessSpec(cloud='aws', region='us-east-1')
            )
        
        self.index = self.pc.Index(self.index_name)
    
    def index_regulatory_documents(self, documents: List[Dict]):
        """å°‡æ³•è¦æ–‡ä»¶ç´¢å¼•è‡³å‘é‡è³‡æ–™åº«"""
        vectors = []
        
        for doc in documents:
            # çµ„åˆæ–‡ä»¶å…§å®¹
            text = f"{doc['title']}\n{doc['content']}"
            
            # ç”Ÿæˆå‘é‡åµŒå…¥
            embedding = self.embedder.encode(text).tolist()
            
            vectors.append({
                'id': doc['id'],
                'values': embedding,
                'metadata': {
                    'title': doc['title'],
                    'source': doc['source'],  # FDA/TFDA/EU MDR
                    'section': doc['section'],
                    'effective_date': doc['effective_date']
                }
            })
        
        # æ‰¹æ¬¡ä¸Šå‚³
        self.index.upsert(vectors=vectors, batch_size=100)
        st.success(f"âœ… å·²ç´¢å¼• {len(vectors)} ç­†æ³•è¦æ–‡ä»¶")
    
    def find_relevant_regulations(
        self,
        submission_text: str,
        top_k: int = 10,
        source_filter: Optional[str] = None
    ) -> List[Dict]:
        """æ‰¾å‡ºèˆ‡é€å¯©æ–‡ä»¶ç›¸é—œçš„æ³•è¦æ¢æ–‡"""
        
        # ç”ŸæˆæŸ¥è©¢å‘é‡
        query_embedding = self.embedder.encode(submission_text).tolist()
        
        # æ§‹å»ºéæ¿¾æ¢ä»¶
        filter_dict = {}
        if source_filter:
            filter_dict['source'] = source_filter
        
        # å‘é‡æª¢ç´¢
        results = self.index.query(
            vector=query_embedding,
            top_k=top_k,
            filter=filter_dict if filter_dict else None,
            include_metadata=True
        )
        
        return [{
            'regulation_id': match['id'],
            'title': match['metadata']['title'],
            'source': match['metadata']['source'],
            'section': match['metadata']['section'],
            'relevance_score': match['score']
        } for match in results['matches']]
    
    async def generate_gap_analysis(
        self,
        submission_text: str,
        relevant_regulations: List[Dict]
    ) -> str:
        """ç”Ÿæˆæ³•è¦ç¼ºå£åˆ†æå ±å‘Š"""
        
        # æ§‹å»ºæç¤ºè©
        regulations_text = "\n\n".join([
            f"ã€{reg['source']} - {reg['section']}ã€‘\n{reg['title']}"
            for reg in relevant_regulations
        ])
        
        prompt = f"""
ä½ æ˜¯ä¸€ä½æ³•è¦ç¬¦åˆæ€§åˆ†æå°ˆå®¶ã€‚

ã€é€å¯©æ–‡ä»¶æ‘˜è¦ã€‘
{submission_text[:2000]}  # é™åˆ¶é•·åº¦é¿å…è¶…étokené™åˆ¶

ã€ç›¸é—œæ³•è¦æ¢æ–‡ã€‘
{regulations_text}

ã€ä»»å‹™ã€‘
åˆ†æé€å¯©æ–‡ä»¶èˆ‡æ³•è¦è¦æ±‚ä¹‹é–“çš„ç¬¦åˆæ€§,è­˜åˆ¥ä»»ä½•ç¼ºå£æˆ–ä¸è¶³ä¹‹è™•ã€‚

ã€è¼¸å‡ºæ ¼å¼ã€‘
# æ³•è¦ç¬¦åˆæ€§ç¼ºå£åˆ†æ

## ç¬¦åˆé …ç›®
- [åˆ—å‡ºå·²æ»¿è¶³çš„æ³•è¦è¦æ±‚]

## ç¼ºå£é …ç›®
- [åˆ—å‡ºç¼ºå°‘æˆ–ä¸å®Œæ•´çš„é …ç›®]

## å»ºè­°è£œå……è³‡æ–™
1. [å…·é«”å»ºè­°]
2. [å…·é«”å»ºè­°]

## é¢¨éšªè©•ä¼°
[è©•ä¼°ä¸ç¬¦åˆé …ç›®çš„åš´é‡ç¨‹åº¦]
"""
        
        model = genai.GenerativeModel('gemini-2.5-flash')
        response = await model.generate_content_async(prompt)
        
        return response.text
9.2 è‡¨åºŠè©¦é©—æ•¸æ“šåˆ†ææ¨¡çµ„
pythonCopy# services/clinical_data_analyzer.py
import pandas as pd
import numpy as np
from scipy import stats
import plotly.graph_objects as go
import streamlit as st

class ClinicalDataAnalyzer:
    """è‡¨åºŠè©¦é©—æ•¸æ“šåˆ†æå™¨"""
    
    @staticmethod
    def analyze_efficacy_data(
        df: pd.DataFrame,
        primary_endpoint: str,
        treatment_col: str = 'treatment_group',
        control_col: str = 'control_group'
    ) -> Dict:
        """åˆ†æç™‚æ•ˆæ•¸æ“š"""
        
        # æè¿°æ€§çµ±è¨ˆ
        treatment_data = df[df[treatment_col] == 1][primary_endpoint]
        control_data = df[df[treatment_col] == 0][primary_endpoint]
        
        results = {
            'treatment': {
                'n': len(treatment_data),
                'mean': treatment_data.mean(),
                'std': treatment_data.std(),
                'median': treatment_data.median(),
                'ci_95': stats.t.interval(
                    0.95,
                    len(treatment_data)-1,
                    treatment_data.mean(),
                    stats.sem(treatment_data)
                )
            },
            'control': {
                'n': len(control_data),
                'mean': control_data.mean(),
                'std': control_data.std(),
                'median': control_data.median(),
                'ci_95': stats.t.interval(
                    0.95,
                    len(control_data)-1,
                    control_data.mean(),
                    stats.sem(control_data)
                )
            }
        }
        
        # çµ±è¨ˆæª¢å®š
        t_stat, p_value = stats.ttest_ind(treatment_data, control_data)
        results['statistical_test'] = {
            'method': 'Independent t-test',
            't_statistic': t_stat,
            'p_value': p_value,
            'significant': p_value < 0.05
        }
        
        # æ•ˆæ‡‰é‡(Cohen's d)
        pooled_std = np.sqrt(
            ((len(treatment_data)-1) * treatment_data.std()**2 +
             (len(control_data)-1) * control_data.std()**2) /
            (len(treatment_data) + len(control_data) - 2)
        )
        cohens_d = (treatment_data.mean() - control_data.mean()) / pooled_std
        results['effect_size'] = {
            'cohens_d': cohens_d,
            'interpretation': ClinicalDataAnalyzer._interpret_cohens_d(cohens_d)
        }
        
        return results
    
    @staticmethod
    def _interpret_cohens_d(d: float) -> str:
        """è§£é‡‹Cohen's dæ•ˆæ‡‰é‡"""
        abs_d = abs(d)
        if abs_d < 0.2:
            return "æ¥µå°æ•ˆæ‡‰"
        elif abs_d < 0.5:
            return "å°æ•ˆæ‡‰"
        elif abs_d < 0.8:
            return "ä¸­ç­‰æ•ˆæ‡‰"
        else:
            return "å¤§æ•ˆæ‡‰"
    
    @staticmethod
    def visualize_results(results: Dict):
        """è¦–è¦ºåŒ–åˆ†æçµæœ"""
        
        # æ£®æ—åœ–(Forest Plot)
        fig = go.Figure()
        
        # æ²»ç™‚çµ„
        fig.add_trace(go.Scatter(
            x=[results['treatment']['mean']],
            y=['Treatment'],
            error_x=dict(
                type='data',
                array=[results['treatment']['mean'] - results['treatment']['ci_95'][0]],
                arrayminus=[results['treatment']['ci_95'][1] - results['treatment']['mean']]
            ),
            mode='markers',
            marker=dict(size=12, color='blue'),
            name='Treatment Group'
        ))
        
        # å°ç…§çµ„
        fig.add_trace(go.Scatter(
            x=[results['control']['mean']],
            y=['Control'],
            error_x=dict(
                type='data',
                array=[results['control']['mean'] - results['control']['ci_95'][0]],
                arrayminus=[results['control']['ci_95'][1] - results['control']['mean']]
            ),
            mode='markers',
            marker=dict(size=12, color='red'),
            name='Control Group'
        ))
        
        fig.update_layout(
            title='ç™‚æ•ˆæ¯”è¼ƒ (95% ä¿¡è³´å€é–“)',
            xaxis_title='ä¸»è¦çµ‚é»æ•¸å€¼',
            yaxis_title='çµ„åˆ¥',
            showlegend=True,
            height=300
        )
        
        st.plotly_chart(fig, use_container_width=True)
        
        # çµ±è¨ˆçµæœè¡¨æ ¼
        st.subheader("çµ±è¨ˆæª¢å®šçµæœ")
        st.write(f"**tçµ±è¨ˆé‡**: {results['statistical_test']['t_statistic']:.4f}")
        st.write(f"**på€¼**: {results['statistical_test']['p_value']:.4f}")
        st.write(f"**æ•ˆæ‡‰é‡(Cohen's d)**: {results['effect_size']['cohens_d']:.4f} ({results['effect_size']['interpretation']})")
        
        if results['statistical_test']['significant']:
            st.success("âœ… å·®ç•°é”çµ±è¨ˆé¡¯è‘—æ€§ (p < 0.05)")
        else:
            st.warning("âš ï¸ å·®ç•°æœªé”çµ±è¨ˆé¡¯è‘—æ€§ (p â‰¥ 0.05)")
9.3 å€å¡Šéˆå¯©æŸ¥è»Œè·¡ç³»çµ±
pythonCopy# services/blockchain_audit.py
import hashlib
import json
from datetime import datetime
from typing import List, Dict
import streamlit as st

class Block:
    """å€å¡Šéˆå€å¡Š"""
    
    def __init__(
        self,
        index: int,
        timestamp: str,
        data: Dict,
        previous_hash: str
    ):
        self.index = index
        self.timestamp = timestamp
        self.data = data
        self.previous_hash = previous_hash
        self.nonce = 0
        self.hash = self.calculate_hash()
    
    def calculate_hash(self) -> str:
        """è¨ˆç®—å€å¡Šé›œæ¹Šå€¼"""
        block_string = json.dumps({
            'index': self.index,
            'timestamp': self.timestamp,
            'data': self.data,
            'previous_hash': self.previous_hash,
            'nonce': self.nonce
        }, sort_keys=True)
        
        return hashlib.sha256(block_string.encode()).hexdigest()
    
    def mine_block(self, difficulty: int = 4):
        """å·¥ä½œé‡è­‰æ˜æŒ–ç¤¦"""
        target = '0' * difficulty
        
        while self.hash[:difficulty] != target:
            self.nonce += 1
            self.hash = self.calculate_hash()

class AuditBlockchain:
    """å¯©æŸ¥è»Œè·¡å€å¡Šéˆ"""
    
    def __init__(self):
        self.chain: List[Block] = []
        self.create_genesis_block()
    
    def create_genesis_block(self):
        """å‰µå»ºå‰µä¸–å€å¡Š"""
        genesis_block = Block(
            index=0,
            timestamp=datetime.now().isoformat(),
            data={'message': 'Genesis Block - TW-SmartReview 2030'},
            previous_hash='0'
        )
        self.chain.append(genesis_block)
    
    def add_audit_record(
        self,
        action_type: str,
        user_id: str,
        document_id: str,
        details: Dict
    ):
        """æ·»åŠ å¯©æŸ¥è¨˜éŒ„"""
        audit_data = {
            'action_type': action_type,  # 'upload', 'review', 'approve', 'reject'
            'user_id': user_id,
            'document_id': document_id,
            'details': details,
            'timestamp': datetime.now().isoformat()
        }
        
        new_block = Block(
            index=len(self.chain),
            timestamp=datetime.now().isoformat(),
            data=audit_data,
            previous_hash=self.chain[-1].hash
        )
        
        new_block.mine_block(difficulty=4)
        self.chain.append(new_block)
        
        st.success(f"âœ… å¯©æŸ¥è¨˜éŒ„å·²å¯«å…¥å€å¡Šéˆ (Block #{new_block.index})")
    
    def verify_chain(self) -> bool:
        """é©—è­‰å€å¡Šéˆå®Œæ•´æ€§"""
        for i in range(1, len(self.chain)):
            current_block = self.chain[i]
            previous_block = self.chain[i-1]
            
            # é©—è­‰ç•¶å‰å€å¡Šé›œæ¹Šå€¼
            if current_block.hash != current_block.calculate_hash():
                st.error(f"âŒ å€å¡Š #{i} é›œæ¹Šå€¼ä¸ç¬¦")
                return False
            
            # é©—è­‰éˆæ¥é—œä¿‚
            if current_block.previous_hash != previous_block.hash:
                st.error(f"âŒ å€å¡Š #{i} éˆæ¥æ–·è£‚")
                return False
        
        return True
    
    def get_audit_trail(self, document_id: str) -> List[Dict]:
        """å–å¾—ç‰¹å®šæ–‡ä»¶çš„å¯©æŸ¥è»Œè·¡"""
        trail = []
        
        for block in self.chain[1:]:  # è·³éå‰µä¸–å€å¡Š
            if block.data['document_id'] == document_id:
                trail.append({
                    'block_index': block.index,
                    'timestamp': block.data['timestamp'],
                    'action': block.data['action_type'],
                    'user': block.data['user_id'],
                    'details': block.data['details'],
                    'block_hash': block.hash
                })
        
        return trail
    
    def export_chain(self, filepath: str):
        """åŒ¯å‡ºå€å¡Šéˆç‚ºJSONæª”æ¡ˆ"""
        chain_data = []
        
        for block in self.chain:
            chain_data.append({
                'index': block.index,
                'timestamp': block.timestamp,
                'data': block.data,
                'previous_hash': block.previous_hash,
                'nonce': block.nonce,
                'hash': block.hash
            })
        
        with open(filepath, 'w', encoding='utf-8') as f:
            json.dump(chain_data, f, indent=2, ensure_ascii=False)

10. ç³»çµ±æ•ˆèƒ½å„ªåŒ–èˆ‡æ“´å±•æ€§
10.1 å¿«å–ç­–ç•¥
pythonCopy# utils/cache_manager.py
import streamlit as st
import hashlib
from functools import wraps
from typing import Callable, Any

class CacheManager:
    """å¿«å–ç®¡ç†å™¨"""
    
    @staticmethod
    def cache_api_response(ttl: int = 3600):
        """å¿«å–APIå›æ‡‰çš„è£é£¾å™¨"""
        def decorator(func: Callable) -> Callable:
            @wraps(func)
            def wrapper(*args, **kwargs):
                # ç”Ÿæˆå¿«å–éµ
                cache_key = CacheManager._generate_cache_key(func.__name__, args, kwargs)
                
                # æª¢æŸ¥å¿«å–
                if cache_key in st.session_state:
                    cached_data, timestamp = st.session_state[cache_key]
                    if (datetime.now() - timestamp).seconds < ttl:
                        st.info("âš¡ å¾å¿«å–è¼‰å…¥çµæœ")
                        return cached_data
                
                # åŸ·è¡Œå‡½å¼
                result = func(*args, **kwargs)
                
                # å­˜å…¥å¿«å–
                st.session_state[cache_key] = (result, datetime.now())
                
                return result
            
            return wrapper
        return decorator
    
    @staticmethod
    def _generate_cache_key(func_name: str, args: tuple, kwargs: dict) -> str:
        """ç”Ÿæˆå¿«å–éµ"""
        key_data = f"{func_name}_{str(args)}_{str(kwargs)}"
        return hashlib.md5(key_data.encode()).hexdigest()
10.2 æ‰¹æ¬¡è™•ç†å„ªåŒ–
pythonCopy# core/batch_processor.py
import asyncio
from concurrent.futures import ThreadPoolExecutor
from typing import List, Callable, Any

class BatchProcessor:
    """æ‰¹æ¬¡è™•ç†å™¨"""
    
    def __init__(self, max_workers: int = 5):
        self.max_workers = max_workers
        self.executor = ThreadPoolExecutor(max_workers=max_workers)
    
    async def process_batch(
        self,
        items: List[Any],
        processor_func: Callable,
        progress_callback: Callable = None
    ) -> List[Any]:
        """æ‰¹æ¬¡è™•ç†é …ç›®"""
        
        loop = asyncio.get_event_loop()
        tasks = []
        
        for idx, item in enumerate(items):
            # å»ºç«‹ç•°æ­¥ä»»å‹™
            task = loop.run_in_executor(
                self.executor,
                processor_func,
                item
            )
            tasks.append(task)
            
            # æ›´æ–°é€²åº¦
            if progress_callback:
                progress_callback((idx + 1) / len(items))
        
        # ç­‰å¾…æ‰€æœ‰ä»»å‹™å®Œæˆ
        results = await asyncio.gather(*tasks, return_exceptions=True)
        
        return results

11. éƒ¨ç½²èˆ‡ç¶­é‹
11.1 Dockerå®¹å™¨åŒ–éƒ¨ç½²
dockerfileCopy# Dockerfile
FROM python:3.11-slim

WORKDIR /app

# å®‰è£ç³»çµ±ä¾è³´
RUN apt-get update && apt-get install -y \
    build-essential \
    curl \
    software-properties-common \
    git \
    && rm -rf /var/lib/apt/lists/*

# è¤‡è£½éœ€æ±‚æª”æ¡ˆ
COPY requirements.txt .

# å®‰è£Pythonå¥—ä»¶
RUN pip install --no-cache-dir -r requirements.txt

# è¤‡è£½æ‡‰ç”¨ç¨‹å¼
COPY . .

# æš´éœ²Streamlité è¨­ç«¯å£
EXPOSE 8501

# å¥åº·æª¢æŸ¥
HEALTHCHECK CMD curl --fail http://localhost:8501/_stcore/health

# å•Ÿå‹•æ‡‰ç”¨
ENTRYPOINT ["streamlit", "run", "app.py", "--server.port=8501", "--server.address=0.0.0.0"]
yamlCopy# docker-compose.yml
version: '3.8'

services:
  streamlit:
    build: .
    ports:
      - "8501:8501"
    environment:
      - GEMINI_API_KEY=${GEMINI_API_KEY}
      - PINECONE_API_KEY=${PINECONE_API_KEY}
    volumes:
      - ./config:/app/config
      - ./data:/app/data
    restart: unless-stopped
    
  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
      - ./ssl:/etc/nginx/ssl
    depends_on:
      - streamlit
11.2 CI/CD Pipeline
yamlCopy# .github/workflows/deploy.yml
name: Deploy TW-SmartReview 2030

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
      
      - name: Install dependencies
        run: |
          pip install -r requirements.txt
          pip install pytest pytest-cov
      
      - name: Run tests
        run: pytest tests/ --cov=. --cov-report=xml
      
      - name: Upload coverage
        uses: codecov/codecov-action@v3
  
  deploy:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Deploy to Streamlit Cloud
        run: |
          curl -X POST \
            -H "Authorization: Bearer ${{ secrets.STREAMLIT_TOKEN }}" \
            https://api.streamlit.io/v1/deploy

12. çµè«–èˆ‡æœªä¾†å±•æœ›
12.1 ç³»çµ±åƒ¹å€¼ç¸½çµ
TW-SmartReview 2030ä»£è¡¨äº†é†«ç™‚å™¨æå¯©æŸ¥é ˜åŸŸçš„å…¸ç¯„è½‰ç§»,å¾å‚³çµ±çš„äººå·¥å¯©æŸ¥æ¨¡å¼é‚å‘æ™ºæ…§å¢å¼·å‹å¯©æŸ¥ã€‚ç³»çµ±é€éä»¥ä¸‹å‰µæ–°å¯¦ç¾çªç ´:

å¯©æŸ¥æ•ˆç‡æå‡70%: AIä»£ç†äººå¯24/7ä¸é–“æ–·å·¥ä½œ,è™•ç†åˆæ­¥ç¯©é¸èˆ‡æ ¼å¼æª¢æŸ¥
å¯©æŸ¥ä¸€è‡´æ€§æå‡: åŸºæ–¼æ¨™æº–åŒ–çš„æç¤ºè©æ¨¡æ¿,æ¸›å°‘äººç‚ºä¸»è§€å·®ç•°
çŸ¥è­˜ç´¯ç©èˆ‡å‚³æ‰¿: é€éå‘é‡è³‡æ–™åº«èˆ‡å€å¡Šéˆ,å»ºç«‹å¯è¿½æº¯çš„å¯©æŸ¥çŸ¥è­˜åº«
åœ‹éš›æ¥è»Œ: æ”¯æ´å¤šåœ‹æ³•è¦æ¨™æº–,ä¿ƒé€²å…¨çƒé†«ç™‚å™¨æå¸‚å ´å‡†å…¥

12.2 æœªä¾†ç™¼å±•è·¯ç·šåœ–
çŸ­æœŸç›®æ¨™(6å€‹æœˆå…§)

æ•´åˆçœŸå¯¦è‡¨åºŠæ¡ˆä¾‹è³‡æ–™åº«,æå‡æ¨¡å‹æº–ç¢ºæ€§
é–‹ç™¼ç§»å‹•ç«¯æ‡‰ç”¨(iOS/Android),æ”¯æ´è¡Œå‹•è¾¦å…¬
å¯¦ä½œå¤šä½¿ç”¨è€…å”ä½œåŠŸèƒ½èˆ‡æ¬Šé™ç®¡ç†ç³»çµ±

ä¸­æœŸç›®æ¨™(1-2å¹´)

å¼•å…¥è¯é‚¦å­¸ç¿’æŠ€è¡“,åœ¨ä¿è­·éš±ç§å‰æä¸‹å…±äº«å¯©æŸ¥ç¶“é©—
é–‹ç™¼é æ¸¬æ€§åˆ†ææ¨¡çµ„,æå‰è­˜åˆ¥é«˜é¢¨éšªç”³è«‹æ¡ˆ
æ•´åˆé›»å­é€å¯©ç³»çµ±(eSubmission Gateway)

é•·æœŸé¡˜æ™¯(3-5å¹´)

å»ºç«‹è·¨åœ‹å¯©æŸ¥è³‡è¨Šå…±äº«å¹³å°
ç™¼å±•è‡ªä¸»å­¸ç¿’å‹AIä»£ç†äºº,æ ¹æ“šå¯©æŸ¥çµæœæŒçºŒå„ªåŒ–
æ¨å‹•é†«ç™‚å™¨æå¯©æŸ¥æµç¨‹çš„å…¨çƒæ¨™æº–åŒ–

TW-SmartReview 2030ä¸åƒ…æ˜¯ä¸€å€‹æŠ€è¡“ç³»çµ±,æ›´æ˜¯æ¨å‹•é†«ç™‚å™¨æç”¢æ¥­å‰µæ–°èˆ‡æ‚£è€…å®‰å…¨çš„é‡è¦åŸºç¤è¨­æ–½ã€‚é€éçµåˆStreamlitçš„æ•æ·é–‹ç™¼èƒ½åŠ›ã€Geminiçš„å…ˆé€²AIæ¨ç†ã€ä»¥åŠYAMLçš„éˆæ´»é…ç½®,æœ¬ç³»çµ±ç‚ºæœªä¾†çš„æ™ºæ…§ç›£ç®¡æ¨¹ç«‹äº†æ–°çš„æ¨™ç«¿ã€‚
